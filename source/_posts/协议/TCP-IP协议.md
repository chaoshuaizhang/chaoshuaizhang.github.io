---
title: TCP/IP协议
date: 2018-07-23 09:06:47
tags: TCP/IP
categories: 协议
---

## 先介绍一下其中的TCP、UDP
>TCP/IP协议中包含多种协议，这里只介绍下TCP/UDP，后期再把ARP、IP等协议补充进来。

### TCP与UDP的区别
>这些参考自计算机网络教材-谢希仁版

### TCP的连接、断开
>下面为传输时会用到的一些状态
![@摘自TCP/IP详解](./1563859396682.png)

#### 三次握手

![Alt text](./1563849314546.png)
>* 第一次握手时客户端发送一个随机的序号seq=i、确认号SYN=1
>* 第二次握手时服务端发送一个随机的序号j、确认号为上次的确认号+1，即i+1、ACK表示应答信号、SYN表示同步信号
>* 第三次握手时客户端发送一个序号（这个序号是客户端第一次发的序号i+1）、一个确认号：上边的序号+1

##### 为什么要三次？
>下面分几种情况来分析。

###### 一种情况
* 服务端收到第一次握手：客户端发送能力、服务端接收能力都OK
* 客户端收到第二次握手：**客户端自己发送能力、客户端自己接收能力、服务端接收能力、服务端发送能力OK**
* 服务端收到第三次握手：**客户端发送能力、客户端接收能力、服务端发送能力、服务端接收能力都OK**
>可以看到在第二次握手后，客户端已经完全知道大家都OK了，但是还需要再发送一个让服务端知道他的发送能力也OK。

###### 另一种情况
>关于握手时消息超时的，这块儿需要再捋一下。

##### 握手失败怎么办？

###### 假设第三次握手失败
>当客户端第三次握手发的消息丢了之后会导致握手失败，我们要做的就是在服务端设置一个**超时计时器**，在服务端发出消息之后，如果在超时时间到了之后还没接收到客户端的反馈消息，则服务端会重新发出一个消息，**重传次数**默认是5，如果重传次数到了之后还没响应，则服务端主动断开连接，由上图所知，此时客户端已经是ESTABLISHED状态。此时客户端如果给服务端发消息。服务端**会响应RST-重新连接**。
![@我们的服务器默认重传次数是2](./1563859011501.png)

#### 四次挥手
>建立一个连接需要三次握手，而终止一个连接要经过4次握手。这由TCP的半关闭（half-close）造成的。既然一个TCP连接是全双工（即数据在两个方向上能同时传递），因此每个方向必须单独地进行关闭。这原则就是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向连接。当一端收到一个FIN，它必须通知应用层另一端几经终止了那个方向的数据传送。发送FIN通常是应用层进行关闭的结果。

![Alt text](./1563879213309.png)

* 连接时：双方只是对握手信号做个响应，不发送有用的数据包
* 断开时：因为是在传输的过程中，突然有一端要断开了（假设客户端请求断开），此时服务端应该怎么办？因为可能有一些数据包还没给客户端发送完毕，但是又要立即反馈客户端的断开请求，怎么办？先回复一个消息：我收到了你的断开请求。继续发送数据包（**此时客户端处于半关闭状态，不会发消息，但可以接收并响应消息**），发送完毕后，发送一个断开请求，收到客户端响应后关闭连接。
>收到一个FIN只意味着在这一方向上没有数据流动。一个TCP连接在收到一个FIN后仍能发送数据。这也就是为什么要四次挥手的原因。

##### TIME_WAIT状态有什么用？
>个人的理解+网上的各种资料查找。不一定对

* 接收FIN之前传入的消息（有可能那些消息传输太慢，或者超时重传什么的）。
* 假如没有TIME_WAIT，一旦接收到服务端的FIN后，又立马与其它服务连接上了，那如果上个服务现在才到，岂不是：上个连接的数据包发到了这个连接上？（这种情况感觉不大可能，它肯定知道是不是自己的数据包吧）

#### 滑动窗口
>出现滑动窗口的原因是：提高TCP的吞吐量，不要接收一个响应一个。更快传输无外乎每次传的多一点，但这里又产生了一个问题：传的多了，次序怎么保证？有包丢失了怎么整？

滑动窗口分为接收窗口和发送窗口。它是传输层进行流控的一种协议，服务端的一次ACK至少包含两个信息：
* 期望得到的下一个包的序号（滑动窗口传输需要对所有的包排好顺序）。
* 自己还能接收多少个包。

###### 举个例子
假设发送了8个，ACK了3个，期望再发3个，那么发送窗口会向右滑动3个，此时窗口里有5个已发送未ACK+3个待发送，此时客户端会继续等待服务端的ACK，直到得到ACK，如果超时则会把窗口中的数据全部重新发送一下。

![@计算机网络-谢希仁](./1563881598390.png)

#### 拥塞控制

##### 产生拥塞的原因
>拥塞的本质原因是**整个系统的各个部分性能不匹配，只有所有部分都平衡了，拥塞问题才会解决。**所以简单的提高处理速度，增大输出链路的容量，增大系统之间的缓存大小，这些都是暂时的解决办法，一段时间后仍会出现拥塞。

##### 拥塞控制和流量控制的区别
>个人的一些理解。
* 拥塞: 链路的带宽太小，导致发送方发的太多，把链路撑爆。
* 流量控制：发送方发的数据可以在链路上传输，但是接收方处理不过来，所以接收方需要告诉发送方传的慢点。

##### 如何检测到发生了拥塞
* 丢弃的分组数
* 超时重传的分组数
* 发送方未按时收到应当到达的确认报文
* ...

##### 拥塞控制的几种算法

###### 基本概念
>发送方维持一个拥塞窗口状态变量cwnd，窗口的大小取决于网络的拥塞度。发送方控制拥塞窗口的原则是：网络未发生拥塞，窗口就增大一些，发生拥塞，减小一些。

###### 慢开始
>在开始发送数据时并不是立即把大量数据注入到网络，因为并不清楚网络的负荷。较好的方式是由小到大，依次提高数据注入量，这样就可以探测到网络的负荷。
具体的实现方式：刚开始发送报文时先把拥塞窗口cwnd设置为一个报文段MSS的数值，然后每收到一对新的报文段的确认后，拥塞窗口就增加一个MSS的数值。

1. 第一次发送一个，接收一个ACK，窗口1->2。
2. 第二次发送两个，接受两个ACK，窗口2->3->4
3. 第三次发送4个，接收四个ACK，窗口4->5->6->7->8

>所以每经过一个传输轮次，窗口cwnd大小就加倍。

###### 拥塞避免
>上边的满开始其实也是有问题的，毕竟是指数递增。所以为防止它增长过快，有设置了一个慢开始门限ssthresh状态变量。
cwnd < ssthresh时，使用慢开始
cwnd > ssthresh时，使用拥塞避免
cwnd = ssthresh时，二者都可使用

拥塞避免的思路是让拥塞窗口cwnd缓慢增大：
* 每经过一个轮回，让cwnd+1而不是加倍，这样增长速度就慢很多了。
* 当网络出现拥塞时，就要把ssthresh设为发生拥塞时的窗口cwnd的一半（不能小于2），cwnd设置为1，然后重新执行慢开始算法。

###### 快重传

###### 快恢复

#### 同时打开
![@出自TCP/IP详解第一卷](./1563852853811.png)

>此时双方没有明确的客户端、服务端之分，双方都是主动建立连接、又被动接收连接，**此时比正常的三次握手多了一次握手**。

#### 同时关闭
![@出自TCP/IP详解第一卷](./1563853023405.png)

>此时一方收到Fin信号后，直接发送一个响应，并断开。（同时关闭说明双方都没有要发送的消息了）
