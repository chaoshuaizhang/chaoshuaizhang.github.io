<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="知识体系树">
<meta property="og:type" content="website">
<meta property="og:title" content="changePosition">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="changePosition">
<meta property="og:description" content="知识体系树">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="changePosition">
<meta name="twitter:description" content="知识体系树">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>changePosition</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">changePosition</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/11/android/RecyclerView分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/11/android/RecyclerView分析/" itemprop="url">RecyclerView分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-11T14:27:05+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/02/java/内部类Handler导致的内存泄漏/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/02/java/内部类Handler导致的内存泄漏/" itemprop="url">内部类Handler导致的内存泄漏</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-02T10:40:15+08:00">
                2018-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于handler内存泄漏的警告"><a href="#关于handler内存泄漏的警告" class="headerlink" title="关于handler内存泄漏的警告"></a>关于handler内存泄漏的警告</h3><blockquote>
<p>使用自定义handler会提示内存泄漏，这个引用链是：<code>activity-&gt;handler-&gt;message-&gt;queue-&gt;looper-&gt;sThreadLocal</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">    <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> + klass.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWeakHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> WeakReference&lt;WangPosCashierActivity&gt; weakReference;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyWeakHandler</span><span class="params">(WangPosCashierActivity activity)</span> </span>&#123;</span><br><span class="line">		weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(activity);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用外部类做一些事</span></span><br><span class="line">		weakReference.get().doSth();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么静态内部类不会产生内存泄漏？<strong>因为它没有持有外部类的引用</strong></p>
</blockquote>
<h3 id="内部类和外部类的关系"><a href="#内部类和外部类的关系" class="headerlink" title="内部类和外部类的关系"></a>内部类和外部类的关系</h3><p><img src="/2018/08/02/java/内部类Handler导致的内存泄漏/./1564709600346.png" alt="Alt text"></p>
<ul>
<li>从上图的字节码文件可以看出：</li>
</ul>
<ol>
<li>静态内部类不持有外部类的引用</li>
<li>普通内部类持有了外部引用（所以它可以访问外部类的任何信息-通过那个引用访问）</li>
</ol>
<ul>
<li>同时也可以引申出一些其他的结论：</li>
</ul>
<ol>
<li>静态内部类和外部类就相当于是完全独立的，普通内部类和外部类是相互依赖的，只有拿着外部类才能创建内部类。</li>
<li>普通内部类中不能声明静态变量、方法，但是可以声明静态常量。<blockquote>
<p>个人理解：类中所有的静态变量、方法是在类加载时都要被加载到内存中，所以加载外部类时就会去加载内部类中的静态变量。<br><strong>那么问题就来了，普通内部类还没有被加载呢，它里边的静态变量却已经被加载了</strong>，这样是有问题的：类还没加载，但是类的变量却加载了。<br>同时也可以明白为什么静态内部类可以有静态变量：因为<strong>加载时静态内部类也会被加载，它里边的静态变量也会被加载，两者都被加载了</strong>，所以没什么问题。</p>
</blockquote>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/28/android/Activity的setContentView加载机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/28/android/Activity的setContentView加载机制/" itemprop="url">Activity的setContentView加载机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-28T16:13:44+08:00">
                2018-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>本篇主要说一下View的显示流程。就要就是setContentView方法。</strong><br>setContentView是通过LayoutInflater把传入的资源id转换为一个View并添加到根布局中，所以我们先分析LayoutInflater的执行机制。</p>
</blockquote>
<h3 id="LayoutInflater用法"><a href="#LayoutInflater用法" class="headerlink" title="LayoutInflater用法"></a>LayoutInflater用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个inflate对象</span></span><br><span class="line">LayoutInflater inflater = LayoutInflater.from(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//根据布局等参数信息构造一个view</span></span><br><span class="line">View mainView = inflater.inflate(R.layout.activity_main, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<h4 id="from的实现"><a href="#from的实现" class="headerlink" title="from的实现"></a>from的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">from</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//可以看出来form真正的实现也是context.getSystemService</span></span><br><span class="line">	LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">	<span class="keyword">if</span> (LayoutInflater == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LayoutInflater not found."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> LayoutInflater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="inflate方法的三个参数"><a href="#inflate方法的三个参数" class="headerlink" title="inflate方法的三个参数"></a>inflate方法的三个参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* resource：资源文件，最终经过一系列操作，转换为View</span></span><br><span class="line"><span class="comment">* root：父布局，如果attachToRoot是true的话，会把上述的view加在root中</span></span><br><span class="line"><span class="comment">* attachToRoot：就是是否添加到root中成为其子view</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">    <span class="comment">//根据资源文件生成一个xml解析器（这个解析器已经包含了资源文件所有的内容了）</span></span><br><span class="line">    <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="inflate的执行流程"><a href="#inflate的执行流程" class="headerlink" title="inflate的执行流程"></a>inflate的执行流程</h4><blockquote>
<p>inflate的执行流程分为几个步骤：</p>
<ol>
<li>把资源文件实例化成为一个xml资源解析器。</li>
<li>根据资源解析器构造一个View。</li>
<li>判断view是否设置params，是否添加到root中。</li>
<li>返回view<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">		<span class="keyword">final</span> Context inflaterContext = mContext;</span><br><span class="line">		<span class="comment">//从解析器中取出属性集合</span></span><br><span class="line">		<span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">		Context lastContext = (Context) mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">		mConstructorArgs[<span class="number">0</span>] = inflaterContext;</span><br><span class="line">		View result = root;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Look for the root node.</span></span><br><span class="line">			<span class="keyword">int</span> type;</span><br><span class="line">			<span class="comment">//查找资源文件的根节点（即start节点）</span></span><br><span class="line">			<span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">				<span class="comment">// Empty</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> InflateException(parser.getPositionDescription() + <span class="string">": No start tag found!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">			<span class="comment">//merge标签的处理</span></span><br><span class="line">			<span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; can be used only with a valid "</span></span><br><span class="line">							+ <span class="string">"ViewGroup root and attachToRoot=true"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				rInflate(parser, root, inflaterContext, attrs, <span class="keyword">false</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//根据root(parent)等一些布局参数生成一个新的view（资源文件id最终也是肯定要转为view的）</span></span><br><span class="line">				<span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				* 注意看LayoutParams的设置：</span></span><br><span class="line"><span class="comment">				* 如果attact是true，说明需要附加在父view中</span></span><br><span class="line"><span class="comment">				* 如果是false：说明不附加。如果root不为null，则使新view的params设置为root的params</span></span><br><span class="line"><span class="comment">				* 否则就不设置params</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				ViewGroup.LayoutParams params = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// Create layout params that match root, if supplied</span></span><br><span class="line">					params = root.generateLayoutParams(attrs);</span><br><span class="line">					<span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">						temp.setLayoutParams(params);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Inflate all children under temp against its context.</span></span><br><span class="line">				rInflateChildren(parser, temp, attrs, <span class="keyword">true</span>);</span><br><span class="line">				<span class="comment">//可以看到当attach=true时，做的操作是把生成的view塞到root中</span></span><br><span class="line">				<span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">					root.addView(temp, params);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//当root是null或者attach=false时，直接返回生成的temp</span></span><br><span class="line">				<span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">					result = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//返回结果：要么是添加了view的root，要么是view本身</span></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<p>OK，inflate过程结束，inflate过程中对merge标签做了处理—merge不能单独使用，必须有接纳它的容器。</p>
</blockquote>
<h3 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView"></a>setContentView</h3><blockquote>
<p>我们这里只分析set资源id的情况，它和setContentView(view…)的区别在于它需要使用layoutInflater把id变为View实例。</p>
</blockquote>
<blockquote>
<p>流程：<br>第一步：执行setContentView<br>第二步：设置decorView<br>第三步：设置主页面内容，从（mContentParent）</p>
<blockquote>
<p>设置主布局内容是挺复杂的，根据我们设置的各个属性去配置我们需要的布局</p>
</blockquote>
</blockquote>
<h4 id="布局层级"><a href="#布局层级" class="headerlink" title="布局层级"></a>布局层级</h4><blockquote>
<p>可能不是很清晰，但是可以看个大概</p>
</blockquote>
<p><img src="/2018/07/28/android/Activity的setContentView加载机制/./1552469205539.png" alt="Alt text"></p>
<h4 id="setContentView-id"><a href="#setContentView-id" class="headerlink" title="setContentView(id)"></a>setContentView(id)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//安装DecorView</span></span><br><span class="line">		installDecor();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">		mContentParent.removeAllViews();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">		<span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">				getContext());</span><br><span class="line">		transitionTo(newScene);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//对于这块儿，为什么没有拿返回值呢？</span></span><br><span class="line">		<span class="comment">//从上边的inflate的源码可以看出：当mContentParent不为空时，attach会</span></span><br><span class="line">		<span class="comment">//设置为true，然后会把对应的布局文件添加到mContentParent中，</span></span><br><span class="line">		<span class="comment">//所以这里不需要拿到view</span></span><br><span class="line">		mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">	&#125;</span><br><span class="line">	mContentParent.requestApplyInsets();</span><br><span class="line">	<span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">	<span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">		cb.onContentChanged();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>mLayoutInflater.inflate(layoutResID, mContentParent)</code>由上面inflate的分析知道，最终生成了一个view并加载到了mContentParent中</p>
</blockquote>
<h3 id="下面对DecorView、ContentParent、resId的联系进行分析"><a href="#下面对DecorView、ContentParent、resId的联系进行分析" class="headerlink" title="下面对DecorView、ContentParent、resId的联系进行分析"></a>下面对DecorView、ContentParent、resId的联系进行分析</h3><h4 id="installDecor"><a href="#installDecor" class="headerlink" title="installDecor()"></a>installDecor()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//此处就是简单生成一个DecorView(context)，由事</span></span><br><span class="line">		<span class="comment">//件分发机制可以知道这个Decor是主Activity的。</span></span><br><span class="line">		mDecor = generateDecor();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//得到主内容布局</span></span><br><span class="line">		mContentParent = generateLayout(mDecor);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="generateLayout-decorview"><a href="#generateLayout-decorview" class="headerlink" title="generateLayout(decorview)"></a>generateLayout(decorview)</h4><blockquote>
<p>根据一些参数设置不同的布局风格，并添加到DecorView中，但是DecorView的层级有很多，这块儿只是在Decor中加了一个View</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Apply data from current theme.</span></span><br><span class="line">	<span class="comment">//得到一些主题资源信息，下边开始设置</span></span><br><span class="line">	TypedArray a = getWindowStyle();</span><br><span class="line">	<span class="keyword">final</span> Context context = getContext();</span><br><span class="line">	<span class="comment">// Inflate the window decor.</span></span><br><span class="line">	<span class="keyword">int</span> layoutResource;</span><br><span class="line">	<span class="comment">//获得一些给Activity设置的特性</span></span><br><span class="line">	<span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line">	<span class="comment">//根据这些特性生成设置对应的layoutResource</span></span><br><span class="line">	mDecor.startChanging();</span><br><span class="line">	View in = mLayoutInflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">	<span class="comment">//把上述的view添加到decor中</span></span><br><span class="line">	decor.addView(in, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">	<span class="comment">//设置根布局（根布局是DecorView的子View）</span></span><br><span class="line">	mContentRoot = (ViewGroup) in;</span><br><span class="line">	<span class="comment">//得到跟布局中的“主内容布局---我们添加的所有布局都会在这里”</span></span><br><span class="line">	<span class="comment">//下面这个findViewById通过看源码发现：是在decorview的布局文件中找的，也就是</span></span><br><span class="line">	<span class="comment">//从上述的mContentRoot中找的。（下边看这个详细的代码实现）</span></span><br><span class="line">	ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">	<span class="comment">// Remaining setup -- of background and title -- that only applies</span></span><br><span class="line">	<span class="comment">// to top-level windows.</span></span><br><span class="line">	<span class="keyword">if</span> (getContainer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//设置DecorView的一些属性</span></span><br><span class="line">		mDecor.setXXX();</span><br><span class="line">	&#125;</span><br><span class="line">	mDecor.finishChanging();</span><br><span class="line">	<span class="comment">//返回decorview中的content---即framelayout</span></span><br><span class="line">	<span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="可以发现，contentParent是从DecorView中根据id-content获得的"><a href="#可以发现，contentParent是从DecorView中根据id-content获得的" class="headerlink" title="可以发现，contentParent是从DecorView中根据id=content获得的"></a>可以发现，contentParent是从DecorView中根据id=content获得的</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends View&gt; <span class="function">T <span class="title">findViewById</span><span class="params">(@IdRes <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// id = ID_ANDROID_CONTENT = com.android.internal.R.id.content</span></span><br><span class="line">    <span class="keyword">return</span> getDecorView().findViewById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/23/协议/TCP-IP协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/23/协议/TCP-IP协议/" itemprop="url">TCP/IP协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-23T09:06:47+08:00">
                2018-07-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/协议/" itemprop="url" rel="index">
                    <span itemprop="name">协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="先介绍一下其中的TCP、UDP"><a href="#先介绍一下其中的TCP、UDP" class="headerlink" title="先介绍一下其中的TCP、UDP"></a>先介绍一下其中的TCP、UDP</h2><blockquote>
<p>TCP/IP协议中包含多种协议，这里只介绍下TCP/UDP，后期再把ARP、IP等协议补充进来。</p>
</blockquote>
<h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><blockquote>
<p>这些参考自计算机网络教材-谢希仁版</p>
</blockquote>
<h3 id="TCP的连接、断开"><a href="#TCP的连接、断开" class="headerlink" title="TCP的连接、断开"></a>TCP的连接、断开</h3><blockquote>
<p>下面为传输时会用到的一些状态<br><img src="/2018/07/23/协议/TCP-IP协议/./1563859396682.png" alt="@摘自TCP/IP详解"></p>
</blockquote>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/2018/07/23/协议/TCP-IP协议/./1563849314546.png" alt="Alt text"></p>
<blockquote>
<ul>
<li>第一次握手时客户端发送一个随机的序号seq=i、确认号SYN=1</li>
<li>第二次握手时服务端发送一个随机的序号j、确认号为上次的确认号+1，即i+1、ACK表示应答信号、SYN表示同步信号</li>
<li>第三次握手时客户端发送一个序号（这个序号是客户端第一次发的序号i+1）、一个确认号：上边的序号+1</li>
</ul>
</blockquote>
<h5 id="为什么要三次？"><a href="#为什么要三次？" class="headerlink" title="为什么要三次？"></a>为什么要三次？</h5><blockquote>
<p>下面分几种情况来分析。</p>
</blockquote>
<h6 id="一种情况"><a href="#一种情况" class="headerlink" title="一种情况"></a>一种情况</h6><ul>
<li>服务端收到第一次握手：客户端发送能力、服务端接收能力都OK</li>
<li>客户端收到第二次握手：<strong>客户端自己发送能力、客户端自己接收能力、服务端接收能力、服务端发送能力OK</strong></li>
<li>服务端收到第三次握手：<strong>客户端发送能力、客户端接收能力、服务端发送能力、服务端接收能力都OK</strong><blockquote>
<p>可以看到在第二次握手后，客户端已经完全知道大家都OK了，但是还需要再发送一个让服务端知道他的发送能力也OK。</p>
</blockquote>
</li>
</ul>
<h6 id="另一种情况"><a href="#另一种情况" class="headerlink" title="另一种情况"></a>另一种情况</h6><blockquote>
<p>关于握手时消息超时的，这块儿需要再捋一下。</p>
</blockquote>
<h5 id="握手失败怎么办？"><a href="#握手失败怎么办？" class="headerlink" title="握手失败怎么办？"></a>握手失败怎么办？</h5><h6 id="假设第三次握手失败"><a href="#假设第三次握手失败" class="headerlink" title="假设第三次握手失败"></a>假设第三次握手失败</h6><blockquote>
<p>当客户端第三次握手发的消息丢了之后会导致握手失败，我们要做的就是在服务端设置一个<strong>超时计时器</strong>，在服务端发出消息之后，如果在超时时间到了之后还没接收到客户端的反馈消息，则服务端会重新发出一个消息，<strong>重传次数</strong>默认是5，如果重传次数到了之后还没响应，则服务端主动断开连接，由上图所知，此时客户端已经是ESTABLISHED状态。此时客户端如果给服务端发消息。服务端<strong>会响应RST-重新连接</strong>。<br><img src="/2018/07/23/协议/TCP-IP协议/./1563859011501.png" alt="@我们的服务器默认重传次数是2"></p>
</blockquote>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><blockquote>
<p>建立一个连接需要三次握手，而终止一个连接要经过4次握手。这由TCP的半关闭（half-close）造成的。既然一个TCP连接是全双工（即数据在两个方向上能同时传递），因此每个方向必须单独地进行关闭。这原则就是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向连接。当一端收到一个FIN，它必须通知应用层另一端几经终止了那个方向的数据传送。发送FIN通常是应用层进行关闭的结果。</p>
</blockquote>
<p><img src="/2018/07/23/协议/TCP-IP协议/./1563879213309.png" alt="Alt text"></p>
<ul>
<li>连接时：双方只是对握手信号做个响应，不发送有用的数据包</li>
<li>断开时：因为是在传输的过程中，突然有一端要断开了（假设客户端请求断开），此时服务端应该怎么办？因为可能有一些数据包还没给客户端发送完毕，但是又要立即反馈客户端的断开请求，怎么办？先回复一个消息：我收到了你的断开请求。继续发送数据包（<strong>此时客户端处于半关闭状态，不会发消息，但可以接收并响应消息</strong>），发送完毕后，发送一个断开请求，收到客户端响应后关闭连接。<blockquote>
<p>收到一个FIN只意味着在这一方向上没有数据流动。一个TCP连接在收到一个FIN后仍能发送数据。这也就是为什么要四次挥手的原因。</p>
</blockquote>
</li>
</ul>
<h5 id="TIME-WAIT状态有什么用？"><a href="#TIME-WAIT状态有什么用？" class="headerlink" title="TIME_WAIT状态有什么用？"></a>TIME_WAIT状态有什么用？</h5><blockquote>
<p>个人的理解+网上的各种资料查找。不一定对</p>
</blockquote>
<ul>
<li>接收FIN之前传入的消息（有可能那些消息传输太慢，或者超时重传什么的）。</li>
<li>假如没有TIME_WAIT，一旦接收到服务端的FIN后，又立马与其它服务连接上了，那如果上个服务现在才到，岂不是：上个连接的数据包发到了这个连接上？（这种情况感觉不大可能，它肯定知道是不是自己的数据包吧）</li>
</ul>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><blockquote>
<p>出现滑动窗口的原因是：提高TCP的吞吐量，不要接收一个响应一个。更快传输无外乎每次传的多一点，但这里又产生了一个问题：传的多了，次序怎么保证？有包丢失了怎么整？</p>
</blockquote>
<p>滑动窗口分为接收窗口和发送窗口。它是传输层进行流控的一种协议，服务端的一次ACK至少包含两个信息：</p>
<ul>
<li>期望得到的下一个包的序号（滑动窗口传输需要对所有的包排好顺序）。</li>
<li>自己还能接收多少个包。</li>
</ul>
<h6 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h6><p>假设发送了8个，ACK了3个，期望再发3个，那么发送窗口会向右滑动3个，此时窗口里有5个已发送未ACK+3个待发送，此时客户端会继续等待服务端的ACK，直到得到ACK，如果超时则会把窗口中的数据全部重新发送一下。</p>
<p><img src="/2018/07/23/协议/TCP-IP协议/./1563881598390.png" alt="@计算机网络-谢希仁"></p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><h5 id="产生拥塞的原因"><a href="#产生拥塞的原因" class="headerlink" title="产生拥塞的原因"></a>产生拥塞的原因</h5><blockquote>
<p>拥塞的本质原因是<strong>整个系统的各个部分性能不匹配，只有所有部分都平衡了，拥塞问题才会解决。</strong>所以简单的提高处理速度，增大输出链路的容量，增大系统之间的缓存大小，这些都是暂时的解决办法，一段时间后仍会出现拥塞。</p>
</blockquote>
<h5 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h5><blockquote>
<p>个人的一些理解。</p>
<ul>
<li>拥塞: 链路的带宽太小，导致发送方发的太多，把链路撑爆。</li>
<li>流量控制：发送方发的数据可以在链路上传输，但是接收方处理不过来，所以接收方需要告诉发送方传的慢点。</li>
</ul>
</blockquote>
<h5 id="如何检测到发生了拥塞"><a href="#如何检测到发生了拥塞" class="headerlink" title="如何检测到发生了拥塞"></a>如何检测到发生了拥塞</h5><ul>
<li>丢弃的分组数</li>
<li>超时重传的分组数</li>
<li>发送方未按时收到应当到达的确认报文</li>
<li>…</li>
</ul>
<h5 id="拥塞控制的几种算法"><a href="#拥塞控制的几种算法" class="headerlink" title="拥塞控制的几种算法"></a>拥塞控制的几种算法</h5><h6 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h6><blockquote>
<p>发送方维持一个拥塞窗口状态变量cwnd，窗口的大小取决于网络的拥塞度。发送方控制拥塞窗口的原则是：网络未发生拥塞，窗口就增大一些，发生拥塞，减小一些。</p>
</blockquote>
<h6 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h6><blockquote>
<p>在开始发送数据时并不是立即把大量数据注入到网络，因为并不清楚网络的负荷。较好的方式是由小到大，依次提高数据注入量，这样就可以探测到网络的负荷。<br>具体的实现方式：刚开始发送报文时先把拥塞窗口cwnd设置为一个报文段MSS的数值，然后每收到一对新的报文段的确认后，拥塞窗口就增加一个MSS的数值。</p>
</blockquote>
<ol>
<li>第一次发送一个，接收一个ACK，窗口1-&gt;2。</li>
<li>第二次发送两个，接受两个ACK，窗口2-&gt;3-&gt;4</li>
<li>第三次发送4个，接收四个ACK，窗口4-&gt;5-&gt;6-&gt;7-&gt;8</li>
</ol>
<blockquote>
<p>所以每经过一个传输轮次，窗口cwnd大小就加倍。</p>
</blockquote>
<h6 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h6><blockquote>
<p>上边的满开始其实也是有问题的，毕竟是指数递增。所以为防止它增长过快，有设置了一个慢开始门限ssthresh状态变量。<br>cwnd &lt; ssthresh时，使用慢开始<br>cwnd &gt; ssthresh时，使用拥塞避免<br>cwnd = ssthresh时，二者都可使用</p>
</blockquote>
<p>拥塞避免的思路是让拥塞窗口cwnd缓慢增大：</p>
<ul>
<li>每经过一个轮回，让cwnd+1而不是加倍，这样增长速度就慢很多了。</li>
<li>当网络出现拥塞时，就要把ssthresh设为发生拥塞时的窗口cwnd的一半（不能小于2），cwnd设置为1，然后重新执行慢开始算法。</li>
</ul>
<h6 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h6><h6 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h6><h4 id="同时打开"><a href="#同时打开" class="headerlink" title="同时打开"></a>同时打开</h4><p><img src="/2018/07/23/协议/TCP-IP协议/./1563852853811.png" alt="@出自TCP/IP详解第一卷"></p>
<blockquote>
<p>此时双方没有明确的客户端、服务端之分，双方都是主动建立连接、又被动接收连接，<strong>此时比正常的三次握手多了一次握手</strong>。</p>
</blockquote>
<h4 id="同时关闭"><a href="#同时关闭" class="headerlink" title="同时关闭"></a>同时关闭</h4><p><img src="/2018/07/23/协议/TCP-IP协议/./1563853023405.png" alt="@出自TCP/IP详解第一卷"></p>
<blockquote>
<p>此时一方收到Fin信号后，直接发送一个响应，并断开。（同时关闭说明双方都没有要发送的消息了）</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/java/ThreadLocal分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/java/ThreadLocal分析/" itemprop="url">ThreadLocal分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T17:52:50+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/01/thread/ThreadFactory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/01/thread/ThreadFactory/" itemprop="url">ThreadFactory</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-01T10:46:38+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h1><blockquote>
<p>好像从没有用过这个ThreadFactory，不过从名字看，应该、是造线程的工厂。如果我们不先设置ThreadFactory的话，它会使用默认的Factory<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">	DefaultThreadFactory() &#123;</span><br><span class="line">		SecurityManager s = System.getSecurityManager();</span><br><span class="line">		<span class="comment">//线程组</span></span><br><span class="line">		group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">		<span class="comment">//设置线程池中默认的线程名</span></span><br><span class="line">		namePrefix = <span class="string">"pool-"</span> + poolNumber.getAndIncrement() + <span class="string">"-thread-"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">		Thread t = <span class="keyword">new</span> Thread(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//恢复为非守护线程</span></span><br><span class="line">		<span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">			t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">//恢复为默认的优先级</span></span><br><span class="line">		<span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">			t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>注意</strong>为什么要执行恢复为非守护线程，默认优先级？</p>
<blockquote>
<p>因为线程的创建是依赖当前线程的，当前线程创建了子线程，则当前线程就是子线程的Parent，子线程的一些属相会直接使用父线程的，所以要恢复为默认的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line"><span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line"><span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">    <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line"><span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">setPriority(priority);</span><br><span class="line"><span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/27/thread/线程池的饱和策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/27/thread/线程池的饱和策略/" itemprop="url">线程池的饱和策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-27T17:46:29+08:00">
                2018-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程池的饱和策略"><a href="#线程池的饱和策略" class="headerlink" title="线程池的饱和策略"></a>线程池的饱和策略</h2><p>@(java)</p>
<blockquote>
<p>当没有更多线程或队列槽可用时，或者因为超出它们的边界，或者在关闭Executor时，ThreadPoolExecutor.execute无法接受任务时，ThreadPoolExecutor会调用rejectedExecution这个方法。<br>什么时候会出现？</p>
<blockquote>
<ul>
<li>AbortPolicy：默认的饱和策略，对于队列满了的情况，会直接抛出异常。</li>
<li>CallerRunsPolicy：会拒绝无法执行（线程队列满了）的线程，线程被拒绝执行后，会交给调用线程来执行。</li>
<li></li>
</ul>
</blockquote>
</blockquote>
<h5 id="主要实现RejectedExecutionHandler接口"><a href="#主要实现RejectedExecutionHandler接口" class="headerlink" title="主要实现RejectedExecutionHandler接口"></a>主要实现RejectedExecutionHandler接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当&#123;<span class="doctag">@link</span> ThreadPoolExecutor #execute execute&#125;无法接受任务</span></span><br><span class="line"><span class="comment">     * 时，会调用这个方法。 当没有更多线程或队列槽可用时，或者因为超出它们</span></span><br><span class="line"><span class="comment">     * 的边界，或者在关闭Executor时，可能会发生这种情况。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="现类"><a href="#现类" class="headerlink" title="现类"></a>现类</h5><h6 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h6><blockquote>
<p>默认的Handler</p>
<ol>
<li>队列满-抛异常</li>
<li>但队列中的任务继续执行</li>
<li>之后即使队列为空，仍不会再往队列中放数据了（因为已经抛异常了）<br><strong>线程数为3，队列为5，则最少可执行8个任务。</strong>三个任务直接执行，其余5个放队列。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当队列满了时，通过直接抛出异常来解决饱和问题，但</span></span><br><span class="line"><span class="comment"> * 是队列中的任务会继续执行，直到执行完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//注意这里是主线程，当其他线程无法执行时，会进入到这里，如果执行r.run()则继续执行，但线程是主线程了</span></span><br><span class="line">	<span class="comment">//System.out.println(Thread.currentThread().getName());</span></span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">										 <span class="string">" rejected from "</span> +</span><br><span class="line">										 e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"my run ... 1 "</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----OVER-----"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">my run ... <span class="number">1</span> pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.util.concurrent.RejectedExecutionException: ......</span><br><span class="line">-----OVER-----</span><br><span class="line">my run ... <span class="number">1</span> pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">-----OVER-----</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>对上述的输出结果有些诧异，因为只有一个线程，为什么会有两个完整的执行体（打印出OVER说明线程执行体执行完成）？</li>
<li>执行两次的原因不清楚，为什么会执行两次？只有一个线程容量，加入第二个任务时应该直接抛异常吧，为什么是执行完第二个任务后才抛异常？<blockquote>
<p><strong>这个容量满了是指当前的线程池以及其缓冲队列的容量都满了才是满了, 而不是线程池的数量。先勉强用这个解释吧，但我看代码仍没看出来！</strong>应该就是这个原因，如果把线程数设置为1，但Queue设置为10，则会先执行一个任务，然后把其余任务加入到队列，如果队列满了，并且没有空闲线程。</p>
</blockquote>
</li>
</ol>
</blockquote>
<h6 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h6><blockquote>
<p>丢弃策略</p>
<ol>
<li>队列满时，丢掉待入队的任务，直到队列有空闲，才加入任务。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//线程数不够，或者executor关闭时，执行</span></span><br><span class="line">	<span class="comment">//此处的空方法表示什么都不执行，即对于那些无法处理的线程不进行任何处理---即丢弃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h6><blockquote>
<p>当线程池没有资源，队列满了时，无法执行的task会<strong>交给调用线程（开启线程池的那个线程）执行。</strong><br>比如有10个任务，3个线程，队列为3，则：<br>1-3三个任务由线程直接执行。<br>4-6三个任务放进队列<br>第7个任务会根据情况，如果没有空闲线程，队列不空闲，则交由调用线程执行</p>
</blockquote>
<p><strong>rejectedExecution执行体</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">	    <span class="comment">//注意看：这里执行了r.run()，请问是哪个线程执行的？</span></span><br><span class="line">	    <span class="comment">//分析下：主线程开启了线程池来执行任务，而当前的方法是在线程调度的过程中发生的</span></span><br><span class="line">	    <span class="comment">//那么谁来进行线程调度？主线程。</span></span><br><span class="line">	    <span class="comment">//所以r.run()也是在main线程池中执行的。</span></span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>例子</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"my run ... 1 "</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h6><blockquote>
<p>移除（丢弃不执行）最老（队头）的task，执行新插入的task</p>
</blockquote>
<p><strong>rejectedExecution实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">	    <span class="comment">//出队</span></span><br><span class="line">        e.getQueue().poll();</span><br><span class="line">        <span class="comment">//由线程池执行新入队的线程</span></span><br><span class="line">        e.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="自定义RejectedExecutionHandler"><a href="#自定义RejectedExecutionHandler" class="headerlink" title="自定义RejectedExecutionHandler"></a>自定义RejectedExecutionHandler</h6><blockquote>
<p>当上述四种策略都无法满足时，可以自定义饱和策略。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//r.run();</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"异常信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/09/java/AOP的一些使用与理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/09/java/AOP的一些使用与理解/" itemprop="url">AOP的一些使用与理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-09T23:56:01+08:00">
                2018-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>[TOC]</p>
<blockquote>
<ul>
<li>OOP作用：日志记录，权限验证，事务控制，性能检测，错误信息检测等等，和核心业务没有任何关系。</li>
<li>为什么要使用切面编程：方便，提取公共的非业务代码，避免一些逻辑校验代码与业务代码混合，可以使用分层思想，从上到下，一个一个的切面，剥离一些“无用”的代码，直到抽出核心代码。</li>
</ul>
</blockquote>
<blockquote>
<p>AOP-AspectJ-SpringAOP-JDK动态代理-CGlib动态代理这几个的关系<br><img src="/2018/06/09/java/AOP的一些使用与理解/./67c610db84fdb4a7d346f0a5d181ca23.png" alt="Alt text"></p>
</blockquote>
<h3 id="实现切面的两种思路"><a href="#实现切面的两种思路" class="headerlink" title="实现切面的两种思路"></a>实现切面的两种思路</h3><h4 id="横向扩展"><a href="#横向扩展" class="headerlink" title="横向扩展"></a>横向扩展</h4><ul>
<li>AspectJ</li>
<li>代理</li>
</ul>
<h4 id="纵向扩展"><a href="#纵向扩展" class="headerlink" title="纵向扩展"></a>纵向扩展</h4><blockquote>
<p>一般通过继承的方式：A要有个大日志的功能，则B继承A，B重写A的方法，添加日志，A又想有监测的功能，则C继承B，重写B的方法，添加监测功能。</p>
</blockquote>
<p>缺点：如上所述，添加的功能越多，代码耦合越大。</p>
<h3 id="AspectJ分析"><a href="#AspectJ分析" class="headerlink" title="AspectJ分析"></a>AspectJ分析</h3><blockquote>
<p>分为两种：</p>
<ul>
<li>基于AspectJ语法编写，然后使用ajc（默认java使用的是javac，因为要编译AspectJ，需要在IDE中改成ajc，或者是使用命令，依赖于aspectjtool包）编译.aj文件，生成标准的class文件。</li>
<li>基于注解，Java语言+aspectj包的注解，通过AspectJ提供的编织器，编织代码到目标class文件中（<strong>但是我反编译class文件，没有看到被织入的代码</strong>）。</li>
</ul>
</blockquote>
<h5 id="织入的概念"><a href="#织入的概念" class="headerlink" title="织入的概念"></a>织入的概念</h5><blockquote>
<p>何为织入？使切面的逻辑代码并入（逻辑上并入或者物理上并入）到业务代码中，这里的逻辑和物理是指：A中调用B称为逻辑织入，A和B融合到一起称为物理织入。</p>
</blockquote>
<ul>
<li>如何织入？两种方式吧（<a href="https://blog.mythsman.com/2017/12/21/1/" target="_blank" rel="noopener">参考网络</a>）</li>
</ul>
<ol>
<li>提供注册机制，通过提供配置文件（注册表）指明那些类需要被切。（<strong>逻辑织入</strong>）</li>
<li>在编译期或者类加载期，优先编译或加载切面代码，然后将切面代码并入到指定的类中，一般都是通过aspectjweaver包实现的。（<strong>物理织入</strong>）</li>
</ol>
<blockquote>
<p>总感觉这两种方式差不多吧，难道第一种是我使用某一个方法时，先查一下它是否进行了切面注册，如果是的话，先执行切面？第二种就是我常用的方式。</p>
</blockquote>
<h5 id="物理织入"><a href="#物理织入" class="headerlink" title="物理织入"></a>物理织入</h5><blockquote>
<p><strong>具体分为三种</strong></p>
<blockquote>
<p>使用AspectJ语法的话，默认只能使用第一种方式（因为.aj文件只能通过ajc编译），使用注解的话，下列三种方式都可以实现。</p>
<ol>
<li>编译时织入<br>利用<strong>ajc编译器替代javac编译器</strong>，直接将源文件(java或者aspect文件)编译成class文件并将切面织入进代码。</li>
<li>编译后织入<br>利用ajc编译器<strong>向javac编译期编译后的</strong>class文件或jar文件织入切面代码。</li>
<li>加载时织入<br><strong>不使用ajc编译器</strong>，利用aspectjweaver.jar工具，使用java agent代理在类加载期将切面织入进代码。</li>
</ol>
</blockquote>
</blockquote>
<p><img src="/2018/06/09/java/AOP的一些使用与理解/./8acf8e36d6042f9459df05007a3c803c.png" alt="Alt text"></p>
<h4 id="第一种、使用AspectJ语法"><a href="#第一种、使用AspectJ语法" class="headerlink" title="第一种、使用AspectJ语法"></a>第一种、使用AspectJ语法</h4><blockquote>
<p>这种方式只需借助<code>aspectjrt.jar、aspectjtools.jar这两个jar包</code></p>
</blockquote>
<h5 id="使用原生AspectJ语法定义切面"><a href="#使用原生AspectJ语法定义切面" class="headerlink" title="使用原生AspectJ语法定义切面"></a>使用原生AspectJ语法定义切面</h5><blockquote>
<p>此文件为TestAspect.aj文件，默认IDE是不能创建.aj文件的，添加spring-aop依赖后就可以创建。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> aspect TestAspect &#123;</span><br><span class="line">    <span class="comment">//定义切点</span></span><br><span class="line">    <span class="function">pointcut <span class="title">webLog</span><span class="params">()</span>: <span class="title">execution</span><span class="params">(<span class="keyword">public</span> * net.shopin.pdaware.common..*.sayHello(..)</span>)</span>;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    before(): webLog() &#123;</span><br><span class="line">        System.out.println(<span class="string">"前置 入参打印"</span> + thisJoinPoint.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    around(): webLog()&#123;</span><br><span class="line">        System.out.println(<span class="string">"环绕打印"</span>);</span><br><span class="line">        <span class="comment">//获得参数名</span></span><br><span class="line">        String[] names = ((CodeSignature) thisJoinPointStaticPart.getSignature()).getParameterNames();</span><br><span class="line">        <span class="comment">//获得参数</span></span><br><span class="line">        Object[] args = thisJoinPoint.getArgs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    after(): webLog(JoinPoint point)&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置 返参打印"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="织入后的文件"><a href="#织入后的文件" class="headerlink" title="织入后的文件"></a>织入后的文件</h5><blockquote>
<p>首先，我没有看到织入成功的文件，配置了ajc但是没生效，所以拷贝一段网络的代码吧。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//前置通知</span></span><br><span class="line">		TestAspect.aspectOf().ajc$before$TestAspect$<span class="number">1</span>$<span class="number">682722</span>c();</span><br><span class="line">		<span class="comment">//核心业务代码</span></span><br><span class="line">		System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span><br><span class="line">		<span class="comment">//后置通知（不清楚为什么这里也有后置通知）</span></span><br><span class="line">		TestAspect.aspectOf().ajc$after$TestAspect$<span class="number">2</span>$<span class="number">682722</span>c();</span><br><span class="line">		<span class="keyword">throw</span> localThrowable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//明明这里有一个后置通知就行了，为什么上边的catch中还会有一个？</span></span><br><span class="line">	TestAspect.aspectOf().ajc$after$TestAspect$<span class="number">2</span>$<span class="number">682722</span>c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="编译后的Aspect文件"><a href="#编译后的Aspect文件" class="headerlink" title="编译后的Aspect文件"></a>编译后的Aspect文件</h5><ul>
<li><p>看到上述的前置后置都是调用TestAspect.aspectOf().XXX来实现打日志，可以联想到可能是个单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestAspect <span class="title">aspectOf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ajc$perSingletonInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NoAspectBoundException(<span class="string">"TestAspect"</span>, ajc$initFailureCause);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ajc$perSingletonInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么时候初始化perSingletonInstance呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态代码块，类加载时就先初始化</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//实例化我们定义的切面对象</span></span><br><span class="line">		ajc$postClinit();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span><br><span class="line">		ajc$initFailureCause = localThrowable;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> ajc$postClinit() &#123;</span><br><span class="line">	<span class="comment">//可以看到在这里实例化了一个TestAspect对象</span></span><br><span class="line">	ajc$perSingletonInstance = <span class="keyword">new</span> TestAspect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过单例来调用前置、后置、环绕等方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> ajc$before$TestAspect$<span class="number">1</span>$<span class="number">682722</span>c() &#123;</span><br><span class="line">	System.out.println(<span class="string">"前置 入参打印"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> ajc$after$TestAspect$<span class="number">2</span>$<span class="number">682722</span>c() &#123;</span><br><span class="line">	System.out.println(<span class="string">"后置 返参打印"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>通过看上边.aj文件的编译情况，可以想到为什么说AspectJ是静态编译了，他就是把在核心业务代码前后调用了一些方法，和我们手动定义一些Util方法是有些类似的，不同的是，这些AspectJ会自动为我们做好。<br>缺点：</p>
</blockquote>
<h4 id="第二种、使用注解"><a href="#第二种、使用注解" class="headerlink" title="第二种、使用注解"></a>第二种、使用注解</h4><blockquote>
<p>这种方式不仅需要借助<code>aspectjrt.jar、aspectjtools.jar这两个jar包</code>还需要<code>aspectjweaver.jar</code>，因为注解的方式需要把目标class文件和切面class文件进行织入。aspectj语法的方式不需要aspectjweaver，不太清楚为什么不需要aspectweaver包，但肯定和它是.aj有关，哈哈。</p>
<blockquote>
<p>下面将讲三种方式：编译时、后、加载时。我从服务端down的class文件中没有织入代码，难道使用的是加载是的织入方式？不是的！Spring的aop借助的是【】</p>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLogAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * net.shopin.pdaware..*Controller.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLog</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLogBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLogAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="方式一、编译时织入"><a href="#方式一、编译时织入" class="headerlink" title="方式一、编译时织入"></a>方式一、编译时织入</h5><blockquote>
<p>所谓编译时织入就是：在使用ajc编译目标.java文件和切面文件时，就进行融合，生成的class文件和上述使用AspectJ语法编写后的织入是一样的。</p>
</blockquote>
<h5 id="方式二、编译后织入"><a href="#方式二、编译后织入" class="headerlink" title="方式二、编译后织入"></a>方式二、编译后织入</h5><blockquote>
<p>编译后织入分为两步。</p>
</blockquote>
<ul>
<li>第一步：使用javac编译目标文件和切面文件，生成.class（和java文件没有区别，看不出什么）。</li>
<li>第二步：使用ajc再次处理（编译？）上述class文件，得到新的织入切面代码后的class文件（此时看到的新的class文件和上述AspectJ语法编译后的class是一样的，单例模式）。</li>
</ul>
<hr>
<blockquote>
<p>上述两种aspect.class时如何织入到target.class文件中的？</p>
<blockquote>
<p>我们在<strong>aspect中定义的有我要切哪些目标类、方法等</strong>，所以编译期会通过这些标识去找到对应的target，然后织入。</p>
</blockquote>
</blockquote>
<h5 id="方式三、加载时织入（LTW）"><a href="#方式三、加载时织入（LTW）" class="headerlink" title="方式三、加载时织入（LTW）"></a>方式三、加载时织入（LTW）</h5><blockquote>
<p>LTW：Load-Time Weaving<br>此时就不借助于ajc工具了。</p>
</blockquote>
<h6 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h6><blockquote>
<p>上述已经说了，编译时、后是通过ajc查看class为标识把目标class和切面class进行关联，那么运行时呢？已经编译过了，咋关联？</p>
<blockquote>
<p>是否可以通过一种方式：在加载目标类时它知道它要被某个切面进行关联，所以JVM要先加载那个切面，然后再加载它自己。也就是在目标类加载之前，其对应的切面必须被加载完成。</p>
</blockquote>
</blockquote>
<p><strong>具体的织入方式需要借助于JavaAgent</strong></p>
<blockquote>
<p>对于javaagent这里就不做详细介绍了，毕竟不清楚。大致拷贝下它的作用</p>
</blockquote>
<ul>
<li>可以在加载 class 文件之前做拦截，对字节码做修改</li>
<li>可以在运行期对已加载类的字节码做变更，但是这种情况下会有很多的限制</li>
<li>还有其他一些小众的功能：<blockquote>
<ul>
<li>获取所有已经加载过的类</li>
<li>获取所有已经初始化过的类（执行过 clinit 方法，是上面的一个子集）</li>
<li>获取某个对象的大小</li>
<li>将某个 jar 加入到 bootstrap classpath 里作为高优先级被 bootstrapClassloader 加载</li>
<li>将某个 jar 加入到 classpath 里供 AppClassloard 去加载</li>
<li>设置某些 native 方法的前缀，主要在查找 native 方法的时候做规则匹配</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>从agent的作用可以看出来，它可以实现运行时的织入。</strong></p>
<h6 id="使用LTW方式的要求"><a href="#使用LTW方式的要求" class="headerlink" title="使用LTW方式的要求"></a>使用LTW方式的要求</h6><blockquote>
<p>官方给了三个要使用LTW的前置条件。</p>
<ol>
<li>All aspects to be used for weaving <strong>must be defined to the weaver before any types to be woven are loaded</strong>. This avoids types being “missed” by aspects added later, with the result that invariants across types fail.<br>在加载需要被织入切面的业务代码前，必须把所有的织入类先加载了。</li>
<li>All aspects visible to the weaver are usable. A visible aspect is one defined by the weaving class loader or one of its parent class loaders. All concrete visible aspects are woven and all abstract visible aspects may be extended.</li>
<li><strong>A class loader may only weave classes that it defines.</strong> It may not weave classes loaded by <strong>a delegate or parent class loader</strong>.<br>类加载器可能只会织入它定义（加载）的那些类。其它加载器、父加载器定义的类他可能无法织入。</li>
</ol>
</blockquote>
<h3 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h3><h5 id="疑惑点"><a href="#疑惑点" class="headerlink" title="疑惑点"></a>疑惑点</h5><blockquote>
<p>总是不清楚SpringAOP这个概念，都说实现方式是JDK动态代理或者是Cglib，但是我在Spring项目中使用的只是AspectJ，所以就一直在想AspectJ是不是也是SpringAOP的一种实现方式，毕竟SpringAOP也依赖了aspectjweaver的包。</p>
</blockquote>
<h6 id="pom中的依赖"><a href="#pom中的依赖" class="headerlink" title="pom中的依赖"></a>pom中的依赖</h6><blockquote>
<p>可以看到spring-aop中也是依赖aspectjweaver的，所以为啥它的实现方式只是代理而没有AspectJ呢？</p>
</blockquote>
<ul>
<li>spring-boot-starter-aop<br><img src="/2018/06/09/java/AOP的一些使用与理解/./de2ffb0b869b69dd743b870a970e2830.png" alt="Alt text"></li>
<li>spring-aop<br><img src="/2018/06/09/java/AOP的一些使用与理解/./eec369c68e59c64f7144db801613ed47.png" alt="Alt text"></li>
</ul>
<h5 id="如何判断你用的是织入方式还是代理方式"><a href="#如何判断你用的是织入方式还是代理方式" class="headerlink" title="如何判断你用的是织入方式还是代理方式"></a>如何判断你用的是织入方式还是代理方式</h5><blockquote>
<p>目前没有看出来，只能通过打印</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IAnimalEat target = (IAnimalEat) factory.getProxy();</span><br><span class="line">System.out.println(<span class="string">"生成的新的代理类："</span> + target.getClass().getName());</span><br></pre></td></tr></table></figure>
<ul>
<li>JDK<br><img src="/2018/06/09/java/AOP的一些使用与理解/./6121ca1a8f560bccbdab7df5bb0d8d61.png" alt="Alt text"></li>
<li>Cglib<br><img src="/2018/06/09/java/AOP的一些使用与理解/./4ad811775c2ba1fe9a2f72e7011385e6.png" alt="Alt text"></li>
</ul>
<h3 id="JDK动态代理原理"><a href="#JDK动态代理原理" class="headerlink" title="JDK动态代理原理"></a>JDK动态代理原理</h3><blockquote>
<p>直接看手写动态代理那块儿就行，重点是为什么非得要接口才能实现</p>
</blockquote>
<h3 id="Cglib代理原理"><a href="#Cglib代理原理" class="headerlink" title="Cglib代理原理"></a>Cglib代理原理</h3><h3 id="SpringAOP分析"><a href="#SpringAOP分析" class="headerlink" title="SpringAOP分析"></a>SpringAOP分析</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><blockquote>
<p>都直到是两种方式，什么有接口是jdk，没接口是jdk。</p>
</blockquote>
<h5 id="模板实例"><a href="#模板实例" class="headerlink" title="模板实例"></a>模板实例</h5><blockquote>
<p>先不用管这个实例会采用什么方式代理，先分析流程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory factory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">IAnimalEat dog = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="comment">//第一步：设置目标代理类</span></span><br><span class="line">factory.setTarget(dog);</span><br><span class="line"><span class="comment">//第二步：设置各种通知</span></span><br><span class="line">factory.addAdvice(<span class="keyword">new</span> BeforeAdvice());</span><br><span class="line">factory.addAdvice(<span class="keyword">new</span> AfterReturnAdvice());</span><br><span class="line"><span class="comment">//得到代理类（这块儿如果没有接口的话，就直接用实体类接受就行，不影响）</span></span><br><span class="line">IAnimalEat target = (IAnimalEat) factory.getProxy();</span><br><span class="line"><span class="comment">//执行业务方法</span></span><br><span class="line">target.eat();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>有个简单的SpringAOP就实现了，当然可以对其进行封装，详见下边的参考文档。</p>
</blockquote>
<h6 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h6><blockquote>
<p>分析上述模板代码的执行流程。</p>
</blockquote>
<p><strong>从模板可以看出，核心方法应该是getProxy()，so我们先分析它。</strong></p>
<ul>
<li><p>ProxyFactory.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.createAopProxy().getProxy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//getAopProxyFactory得到的就是一个DefaultAopProxyFactory()对象</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DefaultAopProxyFactory.java</p>
<blockquote>
<p>核心代码，可以看到具体使用jdk还是cglib全在这里进行判断</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//【1】此处成立则使用JDK代理</span></span><br><span class="line">	<span class="keyword">if</span> (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !<span class="keyword">this</span>.hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">		<span class="comment">//【3】判断targetClass是否是接口，是否是proxy的子类，都是的话用JDK代理，否则Cglib</span></span><br><span class="line">		<span class="keyword">return</span> (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass) ? <span class="keyword">new</span> ObjenesisCglibAopProxy(config) : <span class="keyword">new</span> JdkDynamicAopProxy(config));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法的cache这块儿不太懂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Proxy.class.isAssignableFrom(cl) &amp;&amp; proxyClassCache.containsValue(cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//得到设置的接口类（要么有一个，要么没有）</span></span><br><span class="line">	Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">	<span class="comment">//【2】</span></span><br><span class="line">	<span class="keyword">return</span> ifcs.length == <span class="number">0</span> || ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【1】：config应该就是一个配置类，isOptimize默认是false，isProxyTargetClass默认也是false，但是这两个属性都提供了set方法供我们修改它的值。<br>【2】：hasNoUserSuppliedProxyInterfaces根据是否有接口、接口个数是不是1并且接口是不是SpringProxy类型，来返回true、false。</p>
<blockquote>
<p>先不管第三点，<strong>如果我们想用JDK代理，则需要保证</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Optimize = <span class="keyword">false</span><span class="comment">//是否对产生代理的策略进行优化</span></span><br><span class="line"><span class="number">2</span>. isProxyTargetClass = <span class="keyword">false</span><span class="comment">//设置代理的模式jdk/cglib</span></span><br><span class="line"><span class="number">3</span>. 设置了接口类，并且接口不继承自SpringProxy。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>如何设置接口类？</p>
</blockquote>
<ul>
<li>AdvisedSupport.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getProxiedInterfaces() &#123;</span><br><span class="line">	<span class="comment">//interfaces是一个list对象</span></span><br><span class="line">	<span class="keyword">return</span> (Class[])<span class="keyword">this</span>.interfaces.toArray(<span class="keyword">new</span> Class[<span class="keyword">this</span>.interfaces.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>看一下interfaces是在哪赋值的？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterfaces</span><span class="params">(Class... interfaces)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.interfaces.clear();</span><br><span class="line">	Class[] var2 = interfaces;</span><br><span class="line">	<span class="keyword">int</span> var3 = interfaces.length;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">		Class&lt;?&gt; ifc = var2[var4];</span><br><span class="line">		<span class="comment">//调用addInterface方法，往上述的interfaces里添加接口类</span></span><br><span class="line">		<span class="keyword">this</span>.addInterface(ifc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterface</span><span class="params">(Class&lt;?&gt; intf)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.interfaces.contains(intf)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.interfaces.add(intf);</span><br><span class="line">		<span class="keyword">this</span>.adviceChanged();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>OK，只要设置setInterfaces就行，我们发现<strong>ProxyFactory继承自ProxyCreatorSupport，ProxyCreatorSupport继承自AdvisedSupport</strong>。<br>所以上述的三点可以改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Optimize = <span class="keyword">false</span><span class="comment">//是否对产生代理的策略进行优化</span></span><br><span class="line"><span class="number">2</span>. isProxyTargetClass = <span class="keyword">false</span><span class="comment">//设置代理的模式jdk/cglib</span></span><br><span class="line"><span class="number">3</span>. 设置setInterfaces，并且接口不继承自SpringProxy。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>同时发现设置优化时才会有机会使用Cglib，难道Cglib性能更好？（Cglib：创建慢，执行块，JDK：创建快，执行慢）。</p>
<ul>
<li>所以，最终如果想使用JDK，则需要把模板修改为：</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">factory.setTarget(dog);</span><br><span class="line">factory.setProxyTargetClass(<span class="keyword">false</span>);<span class="comment">//默认false，可不设置</span></span><br><span class="line">factory.setOptimize(<span class="keyword">false</span>);<span class="comment">//默认false，可不设置</span></span><br><span class="line">factory.setInterfaces(IAnimalEat.class);<span class="comment">//设置目标类的接口</span></span><br><span class="line">factory.addAdvice(<span class="keyword">new</span> BeforeAdvice());</span><br><span class="line">factory.addAdvice(<span class="keyword">new</span> AfterReturnAdvice());</span><br><span class="line">IAnimalEat target = (IAnimalEat) factory.getProxy();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行：<br><img src="/2018/06/09/java/AOP的一些使用与理解/./b1b1ed687d431b10051a5c88bcf30d5a.png" alt="Alt text"></p>
</li>
<li><p>如果我们想使用Cglib代理呢？</p>
<blockquote>
<p><strong>必要不充分条件</strong>：上述的三个条件只要有一个不成立就行。<br>忘记了还有一个重要的判断呢。</p>
</blockquote>
</li>
</ul>
<p>【3】：判断targetClass是否是接口类型，是否继承proxy等</p>
<ul>
<li>我们自己定义的代理类不可能是接口，并且一般不会继承自Proxy类，所以当逻辑走到了这里，并且代理类是我们自己定义的时候，一般就会使用Cglib代理。</li>
</ul>
<h4 id="Cglib和JDK比较"><a href="#Cglib和JDK比较" class="headerlink" title="Cglib和JDK比较"></a>Cglib和JDK比较</h4><blockquote>
<p>性能问题：由于Cglib代理是利用ASM字节码生成框架<strong>在内存中生成一个需要被代理类的子类完成代理</strong>，而JDK动态代理是<strong>利用反射</strong>原理完成动态代理，所以Cglib创建的动态代理对象性能比JDk动态代理动态创建出来的代理对象新能要好的多，但是对象创建的速度比JDk动态代理要慢，所以，当Spring使用的是单例情况下可以选用Cglib代理，反之使用JDK动态代理更加合适。同时还有一个问题，被final修饰的类只能使用JDK动态代理，因为被final修饰的类不能被继承，而Cglib则是利用的继承原理实现代理的。<a href="https://my.oschina.net/zicheng/blog/1920892" target="_blank" rel="noopener">摘自</a></p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/V3v3uit9pLyGU-eO9VyArg" target="_blank" rel="noopener">文章</a><br><a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html" target="_blank" rel="noopener">LTW</a><br><a href="https://www.infoq.cn/article/javaagent-illustrated" target="_blank" rel="noopener">JavaAgent</a><br><a href="https://www.cnblogs.com/best/p/5679656.html#_label4" target="_blank" rel="noopener">封装，看了这篇才知道SpringAOP怎么写</a><br><a href="https://blog.csdn.net/luanlouis/article/details/51155821" target="_blank" rel="noopener">参考</a><br><a href="https://my.oschina.net/u/2518341/blog/1806912" target="_blank" rel="noopener">ProxyFactory和ProxyFactoryBean区别</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/02/android/AIDL流程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/02/android/AIDL流程分析/" itemprop="url">AIDL流程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-02T14:29:26+08:00">
                2018-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/14/spring/SOA 学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/14/spring/SOA 学习笔记/" itemprop="url">SOA 学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-14T13:43:05+08:00">
                2018-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SOA-学习笔记"><a href="#SOA-学习笔记" class="headerlink" title="SOA 学习笔记"></a>SOA 学习笔记</h2><h3 id="SOA项目搭建篇"><a href="#SOA项目搭建篇" class="headerlink" title="SOA项目搭建篇"></a>SOA项目搭建篇</h3><p><strong>主要目标是：完全清楚为什么要这么搭建，如何体现解耦、复用</strong></p>
<ol>
<li>大致的继承关系</li>
</ol>
<p><img src="/2018/04/14/spring/SOA 学习笔记/./1534138305704.png" alt="Alt text"></p>
<ul>
<li><p>SOATopPom</p>
<blockquote>
<p>dependency parent是spring-boot-starter-parent<br>最基础的项目只包含一个pom.xml文件，里边主要是：<br>1、第三方的依赖<br>2、伺服地址配置<br>3、部署构件配置<br>4、对于SP项目来说，spring-boot-starter等aop、web包没有包含在这个pom.xml文件中</p>
</blockquote>
</li>
<li><p>SOAParent</p>
<blockquote>
<p>SOAParent是聚合项目（一个prj包含多个module）<br>主项目也只包含一个pom.xml文件，里边是业务层所需的依赖<br>module：<br>  IService - jar：只写具体的接口，不写实现<br>  bean - jar<br>  dao - jar</p>
</blockquote>
</li>
<li><p>SOAProvider</p>
<blockquote>
<p>dependency parent为SOAParent，主要作用是实现IService，规范的情况下，provider中只有serviceImpl，并把实现了的service注册到zookeeper</p>
</blockquote>
</li>
<li><p>SOAConsumer</p>
<blockquote>
<p>consumer的dependency parent不需要为SOAParent（正常情况下消费者是与后台无关的，除非是一个系统既是consumer，又是provider），它只要引入对应的IService就行。</p>
</blockquote>
</li>
</ul>
<h3 id="Dubbo篇"><a href="#Dubbo篇" class="headerlink" title="Dubbo篇"></a>Dubbo篇</h3><h3 id="zookeeper篇"><a href="#zookeeper篇" class="headerlink" title="zookeeper篇"></a>zookeeper篇</h3><ol>
<li><p>zookeeper默认的三个端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对client端提供服务，在provider和consumer中设置registry时使用</span></span><br><span class="line"><span class="number">2181</span></span><br><span class="line"><span class="comment">//服务器与集群中的 Leader 服务器交换信息的端口</span></span><br><span class="line"><span class="number">2888</span></span><br><span class="line"><span class="comment">//一旦集群中的 Leader 服务器挂了，需要一个端口重新进行选举，选出一个新的 Leader</span></span><br><span class="line"><span class="number">3888</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.properties中spring-dubbo的配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用名称</span></span><br><span class="line">spring.dubbo.application.name=dubbo_consumer</span><br><span class="line"><span class="comment">//注册中心地址</span></span><br><span class="line"><span class="comment">//两台服务器，三个zookeeper注册中心（算是伪集群）</span></span><br><span class="line">spring.dubbo.registry.address=zookeeper:<span class="comment">//172.16.103.146:2281?backup=172.16.103.19:2281,172.16.103.136:2381</span></span><br><span class="line"><span class="comment">//协议名称</span></span><br><span class="line">spring.dubbo.protocol.name=dubbo</span><br><span class="line"><span class="comment">//协议端口</span></span><br><span class="line">spring.dubbo.protocol.port=<span class="number">20800</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">spring.dubbo.registry.timeout=<span class="number">6000</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Dubbo-Admin搭建"><a href="#Dubbo-Admin搭建" class="headerlink" title="Dubbo-Admin搭建"></a>Dubbo-Admin搭建</h3><ol start="2">
<li>出现的问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. It is probably not running</span><br><span class="line">	删除data下面除myid之外的其它文件</span><br><span class="line">	保证dataDir、dataDirLog的路径是正确的</span><br><span class="line"><span class="number">2</span>. 实验证明，当provider写了版本号后，consumer必须也要写版本号，不然引不到</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<blockquote>
<p>后台学习推荐书籍<br>spring in action 第四版<br>springboot 揭秘  配合博客<br>dubbo 官网<br>《大型网站技术架构：核心原理与案例分析》<br>《大型网站系统与Java中间件实践》<br>大型分布式网站架构设计与实践<br>SOA理解<br>redis<br>redis开发与运维</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">changePosition</p>
              <p class="site-description motion-element" itemprop="description">知识体系树</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">changePosition</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
