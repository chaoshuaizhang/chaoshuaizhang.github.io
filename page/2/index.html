<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="知识体系树">
<meta property="og:type" content="website">
<meta property="og:title" content="changePosition">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="changePosition">
<meta property="og:description" content="知识体系树">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="changePosition">
<meta name="twitter:description" content="知识体系树">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>changePosition</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">changePosition</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/java/ThreadLocal分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/java/ThreadLocal分析/" itemprop="url">ThreadLocal分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T17:52:50+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/01/thread/ThreadFactory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/01/thread/ThreadFactory/" itemprop="url">ThreadFactory</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-01T10:46:38+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h1><blockquote>
<p>好像从没有用过这个ThreadFactory，不过从名字看，应该、是造线程的工厂。如果我们不先设置ThreadFactory的话，它会使用默认的Factory<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">	DefaultThreadFactory() &#123;</span><br><span class="line">		SecurityManager s = System.getSecurityManager();</span><br><span class="line">		<span class="comment">//线程组</span></span><br><span class="line">		group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">		<span class="comment">//设置线程池中默认的线程名</span></span><br><span class="line">		namePrefix = <span class="string">"pool-"</span> + poolNumber.getAndIncrement() + <span class="string">"-thread-"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">		Thread t = <span class="keyword">new</span> Thread(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//恢复为非守护线程</span></span><br><span class="line">		<span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">			t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">//恢复为默认的优先级</span></span><br><span class="line">		<span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">			t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>注意</strong>为什么要执行恢复为非守护线程，默认优先级？</p>
<blockquote>
<p>因为线程的创建是依赖当前线程的，当前线程创建了子线程，则当前线程就是子线程的Parent，子线程的一些属相会直接使用父线程的，所以要恢复为默认的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line"><span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line"><span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">    <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line"><span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">        acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">setPriority(priority);</span><br><span class="line"><span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/27/thread/线程池的饱和策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/27/thread/线程池的饱和策略/" itemprop="url">线程池的饱和策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-27T17:46:29+08:00">
                2018-06-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程池的饱和策略"><a href="#线程池的饱和策略" class="headerlink" title="线程池的饱和策略"></a>线程池的饱和策略</h2><p>@(java)</p>
<blockquote>
<p>当没有更多线程或队列槽可用时，或者因为超出它们的边界，或者在关闭Executor时，ThreadPoolExecutor.execute无法接受任务时，ThreadPoolExecutor会调用rejectedExecution这个方法。<br>什么时候会出现？</p>
<blockquote>
<ul>
<li>AbortPolicy：默认的饱和策略，对于队列满了的情况，会直接抛出异常。</li>
<li>CallerRunsPolicy：会拒绝无法执行（线程队列满了）的线程，线程被拒绝执行后，会交给调用线程来执行。</li>
<li></li>
</ul>
</blockquote>
</blockquote>
<h5 id="主要实现RejectedExecutionHandler接口"><a href="#主要实现RejectedExecutionHandler接口" class="headerlink" title="主要实现RejectedExecutionHandler接口"></a>主要实现RejectedExecutionHandler接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当&#123;<span class="doctag">@link</span> ThreadPoolExecutor #execute execute&#125;无法接受任务</span></span><br><span class="line"><span class="comment">     * 时，会调用这个方法。 当没有更多线程或队列槽可用时，或者因为超出它们</span></span><br><span class="line"><span class="comment">     * 的边界，或者在关闭Executor时，可能会发生这种情况。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="现类"><a href="#现类" class="headerlink" title="现类"></a>现类</h5><h6 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h6><blockquote>
<p>默认的Handler</p>
<ol>
<li>队列满-抛异常</li>
<li>但队列中的任务继续执行</li>
<li>之后即使队列为空，仍不会再往队列中放数据了（因为已经抛异常了）<br><strong>线程数为3，队列为5，则最少可执行8个任务。</strong>三个任务直接执行，其余5个放队列。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当队列满了时，通过直接抛出异常来解决饱和问题，但</span></span><br><span class="line"><span class="comment"> * 是队列中的任务会继续执行，直到执行完成。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//注意这里是主线程，当其他线程无法执行时，会进入到这里，如果执行r.run()则继续执行，但线程是主线程了</span></span><br><span class="line">	<span class="comment">//System.out.println(Thread.currentThread().getName());</span></span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">										 <span class="string">" rejected from "</span> +</span><br><span class="line">										 e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"my run ... 1 "</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----OVER-----"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">my run ... <span class="number">1</span> pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.util.concurrent.RejectedExecutionException: ......</span><br><span class="line">-----OVER-----</span><br><span class="line">my run ... <span class="number">1</span> pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">-----OVER-----</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>对上述的输出结果有些诧异，因为只有一个线程，为什么会有两个完整的执行体（打印出OVER说明线程执行体执行完成）？</li>
<li>执行两次的原因不清楚，为什么会执行两次？只有一个线程容量，加入第二个任务时应该直接抛异常吧，为什么是执行完第二个任务后才抛异常？<blockquote>
<p><strong>这个容量满了是指当前的线程池以及其缓冲队列的容量都满了才是满了, 而不是线程池的数量。先勉强用这个解释吧，但我看代码仍没看出来！</strong>应该就是这个原因，如果把线程数设置为1，但Queue设置为10，则会先执行一个任务，然后把其余任务加入到队列，如果队列满了，并且没有空闲线程。</p>
</blockquote>
</li>
</ol>
</blockquote>
<h6 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h6><blockquote>
<p>丢弃策略</p>
<ol>
<li>队列满时，丢掉待入队的任务，直到队列有空闲，才加入任务。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//线程数不够，或者executor关闭时，执行</span></span><br><span class="line">	<span class="comment">//此处的空方法表示什么都不执行，即对于那些无法处理的线程不进行任何处理---即丢弃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h6><blockquote>
<p>当线程池没有资源，队列满了时，无法执行的task会<strong>交给调用线程（开启线程池的那个线程）执行。</strong><br>比如有10个任务，3个线程，队列为3，则：<br>1-3三个任务由线程直接执行。<br>4-6三个任务放进队列<br>第7个任务会根据情况，如果没有空闲线程，队列不空闲，则交由调用线程执行</p>
</blockquote>
<p><strong>rejectedExecution执行体</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">	    <span class="comment">//注意看：这里执行了r.run()，请问是哪个线程执行的？</span></span><br><span class="line">	    <span class="comment">//分析下：主线程开启了线程池来执行任务，而当前的方法是在线程调度的过程中发生的</span></span><br><span class="line">	    <span class="comment">//那么谁来进行线程调度？主线程。</span></span><br><span class="line">	    <span class="comment">//所以r.run()也是在main线程池中执行的。</span></span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>例子</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"my run ... 1 "</span> + Thread.currentThread().getName());</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h6><blockquote>
<p>移除（丢弃不执行）最老（队头）的task，执行新插入的task</p>
</blockquote>
<p><strong>rejectedExecution实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">	    <span class="comment">//出队</span></span><br><span class="line">        e.getQueue().poll();</span><br><span class="line">        <span class="comment">//由线程池执行新入队的线程</span></span><br><span class="line">        e.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="自定义RejectedExecutionHandler"><a href="#自定义RejectedExecutionHandler" class="headerlink" title="自定义RejectedExecutionHandler"></a>自定义RejectedExecutionHandler</h6><blockquote>
<p>当上述四种策略都无法满足时，可以自定义饱和策略。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//r.run();</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"异常信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/09/java/AOP的一些使用与理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/09/java/AOP的一些使用与理解/" itemprop="url">AOP的一些使用与理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-09T23:56:01+08:00">
                2018-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>[TOC]</p>
<blockquote>
<ul>
<li>OOP作用：日志记录，权限验证，事务控制，性能检测，错误信息检测等等，和核心业务没有任何关系。</li>
<li>为什么要使用切面编程：方便，提取公共的非业务代码，避免一些逻辑校验代码与业务代码混合，可以使用分层思想，从上到下，一个一个的切面，剥离一些“无用”的代码，直到抽出核心代码。</li>
</ul>
</blockquote>
<blockquote>
<p>AOP-AspectJ-SpringAOP-JDK动态代理-CGlib动态代理这几个的关系<br><img src="/2018/06/09/java/AOP的一些使用与理解/./67c610db84fdb4a7d346f0a5d181ca23.png" alt="Alt text"></p>
</blockquote>
<h3 id="实现切面的两种思路"><a href="#实现切面的两种思路" class="headerlink" title="实现切面的两种思路"></a>实现切面的两种思路</h3><h4 id="横向扩展"><a href="#横向扩展" class="headerlink" title="横向扩展"></a>横向扩展</h4><ul>
<li>AspectJ</li>
<li>代理</li>
</ul>
<h4 id="纵向扩展"><a href="#纵向扩展" class="headerlink" title="纵向扩展"></a>纵向扩展</h4><blockquote>
<p>一般通过继承的方式：A要有个大日志的功能，则B继承A，B重写A的方法，添加日志，A又想有监测的功能，则C继承B，重写B的方法，添加监测功能。</p>
</blockquote>
<p>缺点：如上所述，添加的功能越多，代码耦合越大。</p>
<h3 id="AspectJ分析"><a href="#AspectJ分析" class="headerlink" title="AspectJ分析"></a>AspectJ分析</h3><blockquote>
<p>分为两种：</p>
<ul>
<li>基于AspectJ语法编写，然后使用ajc（默认java使用的是javac，因为要编译AspectJ，需要在IDE中改成ajc，或者是使用命令，依赖于aspectjtool包）编译.aj文件，生成标准的class文件。</li>
<li>基于注解，Java语言+aspectj包的注解，通过AspectJ提供的编织器，编织代码到目标class文件中（<strong>但是我反编译class文件，没有看到被织入的代码</strong>）。</li>
</ul>
</blockquote>
<h5 id="织入的概念"><a href="#织入的概念" class="headerlink" title="织入的概念"></a>织入的概念</h5><blockquote>
<p>何为织入？使切面的逻辑代码并入（逻辑上并入或者物理上并入）到业务代码中，这里的逻辑和物理是指：A中调用B称为逻辑织入，A和B融合到一起称为物理织入。</p>
</blockquote>
<ul>
<li>如何织入？两种方式吧（<a href="https://blog.mythsman.com/2017/12/21/1/" target="_blank" rel="noopener">参考网络</a>）</li>
</ul>
<ol>
<li>提供注册机制，通过提供配置文件（注册表）指明那些类需要被切。（<strong>逻辑织入</strong>）</li>
<li>在编译期或者类加载期，优先编译或加载切面代码，然后将切面代码并入到指定的类中，一般都是通过aspectjweaver包实现的。（<strong>物理织入</strong>）</li>
</ol>
<blockquote>
<p>总感觉这两种方式差不多吧，难道第一种是我使用某一个方法时，先查一下它是否进行了切面注册，如果是的话，先执行切面？第二种就是我常用的方式。</p>
</blockquote>
<h5 id="物理织入"><a href="#物理织入" class="headerlink" title="物理织入"></a>物理织入</h5><blockquote>
<p><strong>具体分为三种</strong></p>
<blockquote>
<p>使用AspectJ语法的话，默认只能使用第一种方式（因为.aj文件只能通过ajc编译），使用注解的话，下列三种方式都可以实现。</p>
<ol>
<li>编译时织入<br>利用<strong>ajc编译器替代javac编译器</strong>，直接将源文件(java或者aspect文件)编译成class文件并将切面织入进代码。</li>
<li>编译后织入<br>利用ajc编译器<strong>向javac编译期编译后的</strong>class文件或jar文件织入切面代码。</li>
<li>加载时织入<br><strong>不使用ajc编译器</strong>，利用aspectjweaver.jar工具，使用java agent代理在类加载期将切面织入进代码。</li>
</ol>
</blockquote>
</blockquote>
<p><img src="/2018/06/09/java/AOP的一些使用与理解/./8acf8e36d6042f9459df05007a3c803c.png" alt="Alt text"></p>
<h4 id="第一种、使用AspectJ语法"><a href="#第一种、使用AspectJ语法" class="headerlink" title="第一种、使用AspectJ语法"></a>第一种、使用AspectJ语法</h4><blockquote>
<p>这种方式只需借助<code>aspectjrt.jar、aspectjtools.jar这两个jar包</code></p>
</blockquote>
<h5 id="使用原生AspectJ语法定义切面"><a href="#使用原生AspectJ语法定义切面" class="headerlink" title="使用原生AspectJ语法定义切面"></a>使用原生AspectJ语法定义切面</h5><blockquote>
<p>此文件为TestAspect.aj文件，默认IDE是不能创建.aj文件的，添加spring-aop依赖后就可以创建。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> aspect TestAspect &#123;</span><br><span class="line">    <span class="comment">//定义切点</span></span><br><span class="line">    <span class="function">pointcut <span class="title">webLog</span><span class="params">()</span>: <span class="title">execution</span><span class="params">(<span class="keyword">public</span> * net.shopin.pdaware.common..*.sayHello(..)</span>)</span>;</span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    before(): webLog() &#123;</span><br><span class="line">        System.out.println(<span class="string">"前置 入参打印"</span> + thisJoinPoint.getArgs());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    around(): webLog()&#123;</span><br><span class="line">        System.out.println(<span class="string">"环绕打印"</span>);</span><br><span class="line">        <span class="comment">//获得参数名</span></span><br><span class="line">        String[] names = ((CodeSignature) thisJoinPointStaticPart.getSignature()).getParameterNames();</span><br><span class="line">        <span class="comment">//获得参数</span></span><br><span class="line">        Object[] args = thisJoinPoint.getArgs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    after(): webLog(JoinPoint point)&#123;</span><br><span class="line">        System.out.println(<span class="string">"后置 返参打印"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="织入后的文件"><a href="#织入后的文件" class="headerlink" title="织入后的文件"></a>织入后的文件</h5><blockquote>
<p>首先，我没有看到织入成功的文件，配置了ajc但是没生效，所以拷贝一段网络的代码吧。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//前置通知</span></span><br><span class="line">		TestAspect.aspectOf().ajc$before$TestAspect$<span class="number">1</span>$<span class="number">682722</span>c();</span><br><span class="line">		<span class="comment">//核心业务代码</span></span><br><span class="line">		System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span><br><span class="line">		<span class="comment">//后置通知（不清楚为什么这里也有后置通知）</span></span><br><span class="line">		TestAspect.aspectOf().ajc$after$TestAspect$<span class="number">2</span>$<span class="number">682722</span>c();</span><br><span class="line">		<span class="keyword">throw</span> localThrowable;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//明明这里有一个后置通知就行了，为什么上边的catch中还会有一个？</span></span><br><span class="line">	TestAspect.aspectOf().ajc$after$TestAspect$<span class="number">2</span>$<span class="number">682722</span>c();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="编译后的Aspect文件"><a href="#编译后的Aspect文件" class="headerlink" title="编译后的Aspect文件"></a>编译后的Aspect文件</h5><ul>
<li><p>看到上述的前置后置都是调用TestAspect.aspectOf().XXX来实现打日志，可以联想到可能是个单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestAspect <span class="title">aspectOf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ajc$perSingletonInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NoAspectBoundException(<span class="string">"TestAspect"</span>, ajc$initFailureCause);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ajc$perSingletonInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么时候初始化perSingletonInstance呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态代码块，类加载时就先初始化</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//实例化我们定义的切面对象</span></span><br><span class="line">		ajc$postClinit();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable localThrowable) &#123;</span><br><span class="line">		ajc$initFailureCause = localThrowable;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> ajc$postClinit() &#123;</span><br><span class="line">	<span class="comment">//可以看到在这里实例化了一个TestAspect对象</span></span><br><span class="line">	ajc$perSingletonInstance = <span class="keyword">new</span> TestAspect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过单例来调用前置、后置、环绕等方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> ajc$before$TestAspect$<span class="number">1</span>$<span class="number">682722</span>c() &#123;</span><br><span class="line">	System.out.println(<span class="string">"前置 入参打印"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> ajc$after$TestAspect$<span class="number">2</span>$<span class="number">682722</span>c() &#123;</span><br><span class="line">	System.out.println(<span class="string">"后置 返参打印"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>通过看上边.aj文件的编译情况，可以想到为什么说AspectJ是静态编译了，他就是把在核心业务代码前后调用了一些方法，和我们手动定义一些Util方法是有些类似的，不同的是，这些AspectJ会自动为我们做好。<br>缺点：</p>
</blockquote>
<h4 id="第二种、使用注解"><a href="#第二种、使用注解" class="headerlink" title="第二种、使用注解"></a>第二种、使用注解</h4><blockquote>
<p>这种方式不仅需要借助<code>aspectjrt.jar、aspectjtools.jar这两个jar包</code>还需要<code>aspectjweaver.jar</code>，因为注解的方式需要把目标class文件和切面class文件进行织入。aspectj语法的方式不需要aspectjweaver，不太清楚为什么不需要aspectweaver包，但肯定和它是.aj有关，哈哈。</p>
<blockquote>
<p>下面将讲三种方式：编译时、后、加载时。我从服务端down的class文件中没有织入代码，难道使用的是加载是的织入方式？不是的！Spring的aop借助的是【】</p>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebLogAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * net.shopin.pdaware..*Controller.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLog</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLogBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"webLog()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLogAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="方式一、编译时织入"><a href="#方式一、编译时织入" class="headerlink" title="方式一、编译时织入"></a>方式一、编译时织入</h5><blockquote>
<p>所谓编译时织入就是：在使用ajc编译目标.java文件和切面文件时，就进行融合，生成的class文件和上述使用AspectJ语法编写后的织入是一样的。</p>
</blockquote>
<h5 id="方式二、编译后织入"><a href="#方式二、编译后织入" class="headerlink" title="方式二、编译后织入"></a>方式二、编译后织入</h5><blockquote>
<p>编译后织入分为两步。</p>
</blockquote>
<ul>
<li>第一步：使用javac编译目标文件和切面文件，生成.class（和java文件没有区别，看不出什么）。</li>
<li>第二步：使用ajc再次处理（编译？）上述class文件，得到新的织入切面代码后的class文件（此时看到的新的class文件和上述AspectJ语法编译后的class是一样的，单例模式）。</li>
</ul>
<hr>
<blockquote>
<p>上述两种aspect.class时如何织入到target.class文件中的？</p>
<blockquote>
<p>我们在<strong>aspect中定义的有我要切哪些目标类、方法等</strong>，所以编译期会通过这些标识去找到对应的target，然后织入。</p>
</blockquote>
</blockquote>
<h5 id="方式三、加载时织入（LTW）"><a href="#方式三、加载时织入（LTW）" class="headerlink" title="方式三、加载时织入（LTW）"></a>方式三、加载时织入（LTW）</h5><blockquote>
<p>LTW：Load-Time Weaving<br>此时就不借助于ajc工具了。</p>
</blockquote>
<h6 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h6><blockquote>
<p>上述已经说了，编译时、后是通过ajc查看class为标识把目标class和切面class进行关联，那么运行时呢？已经编译过了，咋关联？</p>
<blockquote>
<p>是否可以通过一种方式：在加载目标类时它知道它要被某个切面进行关联，所以JVM要先加载那个切面，然后再加载它自己。也就是在目标类加载之前，其对应的切面必须被加载完成。</p>
</blockquote>
</blockquote>
<p><strong>具体的织入方式需要借助于JavaAgent</strong></p>
<blockquote>
<p>对于javaagent这里就不做详细介绍了，毕竟不清楚。大致拷贝下它的作用</p>
</blockquote>
<ul>
<li>可以在加载 class 文件之前做拦截，对字节码做修改</li>
<li>可以在运行期对已加载类的字节码做变更，但是这种情况下会有很多的限制</li>
<li>还有其他一些小众的功能：<blockquote>
<ul>
<li>获取所有已经加载过的类</li>
<li>获取所有已经初始化过的类（执行过 clinit 方法，是上面的一个子集）</li>
<li>获取某个对象的大小</li>
<li>将某个 jar 加入到 bootstrap classpath 里作为高优先级被 bootstrapClassloader 加载</li>
<li>将某个 jar 加入到 classpath 里供 AppClassloard 去加载</li>
<li>设置某些 native 方法的前缀，主要在查找 native 方法的时候做规则匹配</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>从agent的作用可以看出来，它可以实现运行时的织入。</strong></p>
<h6 id="使用LTW方式的要求"><a href="#使用LTW方式的要求" class="headerlink" title="使用LTW方式的要求"></a>使用LTW方式的要求</h6><blockquote>
<p>官方给了三个要使用LTW的前置条件。</p>
<ol>
<li>All aspects to be used for weaving <strong>must be defined to the weaver before any types to be woven are loaded</strong>. This avoids types being “missed” by aspects added later, with the result that invariants across types fail.<br>在加载需要被织入切面的业务代码前，必须把所有的织入类先加载了。</li>
<li>All aspects visible to the weaver are usable. A visible aspect is one defined by the weaving class loader or one of its parent class loaders. All concrete visible aspects are woven and all abstract visible aspects may be extended.</li>
<li><strong>A class loader may only weave classes that it defines.</strong> It may not weave classes loaded by <strong>a delegate or parent class loader</strong>.<br>类加载器可能只会织入它定义（加载）的那些类。其它加载器、父加载器定义的类他可能无法织入。</li>
</ol>
</blockquote>
<h3 id="SpringAOP"><a href="#SpringAOP" class="headerlink" title="SpringAOP"></a>SpringAOP</h3><h5 id="疑惑点"><a href="#疑惑点" class="headerlink" title="疑惑点"></a>疑惑点</h5><blockquote>
<p>总是不清楚SpringAOP这个概念，都说实现方式是JDK动态代理或者是Cglib，但是我在Spring项目中使用的只是AspectJ，所以就一直在想AspectJ是不是也是SpringAOP的一种实现方式，毕竟SpringAOP也依赖了aspectjweaver的包。</p>
</blockquote>
<h6 id="pom中的依赖"><a href="#pom中的依赖" class="headerlink" title="pom中的依赖"></a>pom中的依赖</h6><blockquote>
<p>可以看到spring-aop中也是依赖aspectjweaver的，所以为啥它的实现方式只是代理而没有AspectJ呢？</p>
</blockquote>
<ul>
<li>spring-boot-starter-aop<br><img src="/2018/06/09/java/AOP的一些使用与理解/./de2ffb0b869b69dd743b870a970e2830.png" alt="Alt text"></li>
<li>spring-aop<br><img src="/2018/06/09/java/AOP的一些使用与理解/./eec369c68e59c64f7144db801613ed47.png" alt="Alt text"></li>
</ul>
<h5 id="如何判断你用的是织入方式还是代理方式"><a href="#如何判断你用的是织入方式还是代理方式" class="headerlink" title="如何判断你用的是织入方式还是代理方式"></a>如何判断你用的是织入方式还是代理方式</h5><blockquote>
<p>目前没有看出来，只能通过打印</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IAnimalEat target = (IAnimalEat) factory.getProxy();</span><br><span class="line">System.out.println(<span class="string">"生成的新的代理类："</span> + target.getClass().getName());</span><br></pre></td></tr></table></figure>
<ul>
<li>JDK<br><img src="/2018/06/09/java/AOP的一些使用与理解/./6121ca1a8f560bccbdab7df5bb0d8d61.png" alt="Alt text"></li>
<li>Cglib<br><img src="/2018/06/09/java/AOP的一些使用与理解/./4ad811775c2ba1fe9a2f72e7011385e6.png" alt="Alt text"></li>
</ul>
<h3 id="JDK动态代理原理"><a href="#JDK动态代理原理" class="headerlink" title="JDK动态代理原理"></a>JDK动态代理原理</h3><blockquote>
<p>直接看手写动态代理那块儿就行，重点是为什么非得要接口才能实现</p>
</blockquote>
<h3 id="Cglib代理原理"><a href="#Cglib代理原理" class="headerlink" title="Cglib代理原理"></a>Cglib代理原理</h3><h3 id="SpringAOP分析"><a href="#SpringAOP分析" class="headerlink" title="SpringAOP分析"></a>SpringAOP分析</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><blockquote>
<p>都直到是两种方式，什么有接口是jdk，没接口是jdk。</p>
</blockquote>
<h5 id="模板实例"><a href="#模板实例" class="headerlink" title="模板实例"></a>模板实例</h5><blockquote>
<p>先不用管这个实例会采用什么方式代理，先分析流程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory factory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">IAnimalEat dog = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="comment">//第一步：设置目标代理类</span></span><br><span class="line">factory.setTarget(dog);</span><br><span class="line"><span class="comment">//第二步：设置各种通知</span></span><br><span class="line">factory.addAdvice(<span class="keyword">new</span> BeforeAdvice());</span><br><span class="line">factory.addAdvice(<span class="keyword">new</span> AfterReturnAdvice());</span><br><span class="line"><span class="comment">//得到代理类（这块儿如果没有接口的话，就直接用实体类接受就行，不影响）</span></span><br><span class="line">IAnimalEat target = (IAnimalEat) factory.getProxy();</span><br><span class="line"><span class="comment">//执行业务方法</span></span><br><span class="line">target.eat();</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>有个简单的SpringAOP就实现了，当然可以对其进行封装，详见下边的参考文档。</p>
</blockquote>
<h6 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h6><blockquote>
<p>分析上述模板代码的执行流程。</p>
</blockquote>
<p><strong>从模板可以看出，核心方法应该是getProxy()，so我们先分析它。</strong></p>
<ul>
<li><p>ProxyFactory.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.createAopProxy().getProxy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//getAopProxyFactory得到的就是一个DefaultAopProxyFactory()对象</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DefaultAopProxyFactory.java</p>
<blockquote>
<p>核心代码，可以看到具体使用jdk还是cglib全在这里进行判断</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//【1】此处成立则使用JDK代理</span></span><br><span class="line">	<span class="keyword">if</span> (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !<span class="keyword">this</span>.hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">		<span class="comment">//【3】判断targetClass是否是接口，是否是proxy的子类，都是的话用JDK代理，否则Cglib</span></span><br><span class="line">		<span class="keyword">return</span> (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass) ? <span class="keyword">new</span> ObjenesisCglibAopProxy(config) : <span class="keyword">new</span> JdkDynamicAopProxy(config));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法的cache这块儿不太懂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Proxy.class.isAssignableFrom(cl) &amp;&amp; proxyClassCache.containsValue(cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//得到设置的接口类（要么有一个，要么没有）</span></span><br><span class="line">	Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">	<span class="comment">//【2】</span></span><br><span class="line">	<span class="keyword">return</span> ifcs.length == <span class="number">0</span> || ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【1】：config应该就是一个配置类，isOptimize默认是false，isProxyTargetClass默认也是false，但是这两个属性都提供了set方法供我们修改它的值。<br>【2】：hasNoUserSuppliedProxyInterfaces根据是否有接口、接口个数是不是1并且接口是不是SpringProxy类型，来返回true、false。</p>
<blockquote>
<p>先不管第三点，<strong>如果我们想用JDK代理，则需要保证</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Optimize = <span class="keyword">false</span><span class="comment">//是否对产生代理的策略进行优化</span></span><br><span class="line"><span class="number">2</span>. isProxyTargetClass = <span class="keyword">false</span><span class="comment">//设置代理的模式jdk/cglib</span></span><br><span class="line"><span class="number">3</span>. 设置了接口类，并且接口不继承自SpringProxy。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>如何设置接口类？</p>
</blockquote>
<ul>
<li>AdvisedSupport.java<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getProxiedInterfaces() &#123;</span><br><span class="line">	<span class="comment">//interfaces是一个list对象</span></span><br><span class="line">	<span class="keyword">return</span> (Class[])<span class="keyword">this</span>.interfaces.toArray(<span class="keyword">new</span> Class[<span class="keyword">this</span>.interfaces.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>看一下interfaces是在哪赋值的？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterfaces</span><span class="params">(Class... interfaces)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.interfaces.clear();</span><br><span class="line">	Class[] var2 = interfaces;</span><br><span class="line">	<span class="keyword">int</span> var3 = interfaces.length;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">		Class&lt;?&gt; ifc = var2[var4];</span><br><span class="line">		<span class="comment">//调用addInterface方法，往上述的interfaces里添加接口类</span></span><br><span class="line">		<span class="keyword">this</span>.addInterface(ifc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterface</span><span class="params">(Class&lt;?&gt; intf)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.interfaces.contains(intf)) &#123;</span><br><span class="line">		<span class="keyword">this</span>.interfaces.add(intf);</span><br><span class="line">		<span class="keyword">this</span>.adviceChanged();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>OK，只要设置setInterfaces就行，我们发现<strong>ProxyFactory继承自ProxyCreatorSupport，ProxyCreatorSupport继承自AdvisedSupport</strong>。<br>所以上述的三点可以改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Optimize = <span class="keyword">false</span><span class="comment">//是否对产生代理的策略进行优化</span></span><br><span class="line"><span class="number">2</span>. isProxyTargetClass = <span class="keyword">false</span><span class="comment">//设置代理的模式jdk/cglib</span></span><br><span class="line"><span class="number">3</span>. 设置setInterfaces，并且接口不继承自SpringProxy。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>同时发现设置优化时才会有机会使用Cglib，难道Cglib性能更好？（Cglib：创建慢，执行块，JDK：创建快，执行慢）。</p>
<ul>
<li>所以，最终如果想使用JDK，则需要把模板修改为：</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">factory.setTarget(dog);</span><br><span class="line">factory.setProxyTargetClass(<span class="keyword">false</span>);<span class="comment">//默认false，可不设置</span></span><br><span class="line">factory.setOptimize(<span class="keyword">false</span>);<span class="comment">//默认false，可不设置</span></span><br><span class="line">factory.setInterfaces(IAnimalEat.class);<span class="comment">//设置目标类的接口</span></span><br><span class="line">factory.addAdvice(<span class="keyword">new</span> BeforeAdvice());</span><br><span class="line">factory.addAdvice(<span class="keyword">new</span> AfterReturnAdvice());</span><br><span class="line">IAnimalEat target = (IAnimalEat) factory.getProxy();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行：<br><img src="/2018/06/09/java/AOP的一些使用与理解/./b1b1ed687d431b10051a5c88bcf30d5a.png" alt="Alt text"></p>
</li>
<li><p>如果我们想使用Cglib代理呢？</p>
<blockquote>
<p><strong>必要不充分条件</strong>：上述的三个条件只要有一个不成立就行。<br>忘记了还有一个重要的判断呢。</p>
</blockquote>
</li>
</ul>
<p>【3】：判断targetClass是否是接口类型，是否继承proxy等</p>
<ul>
<li>我们自己定义的代理类不可能是接口，并且一般不会继承自Proxy类，所以当逻辑走到了这里，并且代理类是我们自己定义的时候，一般就会使用Cglib代理。</li>
</ul>
<h4 id="Cglib和JDK比较"><a href="#Cglib和JDK比较" class="headerlink" title="Cglib和JDK比较"></a>Cglib和JDK比较</h4><blockquote>
<p>性能问题：由于Cglib代理是利用ASM字节码生成框架<strong>在内存中生成一个需要被代理类的子类完成代理</strong>，而JDK动态代理是<strong>利用反射</strong>原理完成动态代理，所以Cglib创建的动态代理对象性能比JDk动态代理动态创建出来的代理对象新能要好的多，但是对象创建的速度比JDk动态代理要慢，所以，当Spring使用的是单例情况下可以选用Cglib代理，反之使用JDK动态代理更加合适。同时还有一个问题，被final修饰的类只能使用JDK动态代理，因为被final修饰的类不能被继承，而Cglib则是利用的继承原理实现代理的。<a href="https://my.oschina.net/zicheng/blog/1920892" target="_blank" rel="noopener">摘自</a></p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/V3v3uit9pLyGU-eO9VyArg" target="_blank" rel="noopener">文章</a><br><a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html" target="_blank" rel="noopener">LTW</a><br><a href="https://www.infoq.cn/article/javaagent-illustrated" target="_blank" rel="noopener">JavaAgent</a><br><a href="https://www.cnblogs.com/best/p/5679656.html#_label4" target="_blank" rel="noopener">封装，看了这篇才知道SpringAOP怎么写</a><br><a href="https://blog.csdn.net/luanlouis/article/details/51155821" target="_blank" rel="noopener">参考</a><br><a href="https://my.oschina.net/u/2518341/blog/1806912" target="_blank" rel="noopener">ProxyFactory和ProxyFactoryBean区别</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/03/android/Binder在AIDL中的应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/03/android/Binder在AIDL中的应用/" itemprop="url">Binder在AIDL中的应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T17:36:04+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="先看一张图"><a href="#先看一张图" class="headerlink" title="先看一张图"></a>先看一张图</h1><blockquote>
<p>这张图描述了AIDL进程间通信的大致流程。<br><strong>同时它也是服务绑定的过程，只不过涉及的一些类：ApplicationThread、IServiceConnection.aidl、InnerConnection、Handler等没有列出来。</strong></p>
</blockquote>
<p><img src="/2018/06/03/android/Binder在AIDL中的应用/./1564889071567.png" alt="Alt text"></p>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><h2 id="创建服务时构造一个binder"><a href="#创建服务时构造一个binder" class="headerlink" title="创建服务时构造一个binder"></a>创建服务时构造一个binder</h2><p>public class BookManageService extends Service {</p>
<pre><code>//在服务端创建一个binder对象，当客户端绑定时，返回这个binder给客户端
private IBinder mBinder = new IBookManager.Stub() {
    @Override
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
        return super.onTransact(code, data, reply, flags);
    }
    //具体的实现类
    @Override
    public List&lt;Book&gt; getBookList() throws RemoteException {
        return list;
    }
    @Override
    public void addBook(Book book) throws RemoteException {
        list.add(book);
    }
};
</code></pre><p>}</p>
<h3 id="new-Stub-时做了什么"><a href="#new-Stub-时做了什么" class="headerlink" title="new Stub()时做了什么"></a>new Stub()时做了什么</h3><blockquote>
<p>new Stub时把DESCRIPTOR和具体的实现类做了关联，便于后期找到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这个this就是当前的匿名内部类，后期根据这个DESCRIPTOR查找对应的IBookManager来操作相关方法</span></span><br><span class="line">	<span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用父类的attachInterface方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachInterface</span><span class="params">(IInterface owner, String descriptor)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//把当前的Stub-Binder的具体实现类赋值给mOwner</span></span><br><span class="line">	mOwner = owner;</span><br><span class="line">	mDescriptor = descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="把服务端构造的Binder返给客户端"><a href="#把服务端构造的Binder返给客户端" class="headerlink" title="把服务端构造的Binder返给客户端"></a>把服务端构造的Binder返给客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//把服务端的Binder对象传给client端</span></span><br><span class="line">	<span class="keyword">return</span> mBinder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="绑定服务"><a href="#绑定服务" class="headerlink" title="绑定服务"></a>绑定服务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//【注意】相同进程时返回的service是服务端创建的那个binder，不同进城时返回的是服务端binder的代理binder-BiderProxy</span></span><br><span class="line">		<span class="comment">//客户端要想和服务端通信，需要把服务端的binder构造成一个服务端的操作实例</span></span><br><span class="line">		<span class="comment">//最终返回一个服务端操作实例的代理类，用代理类来调服务端相应的方法</span></span><br><span class="line">        bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>客户端调用bookManager的方法时实际调用的是IBookManager.Stub的内部类Proxy相应的方法。</li>
<li>activity发起绑定服务后，会经过一大圈最终回调到onServiceConnected，返回相应的binder，其中涉及到跨进程，handler消息机制等。</li>
</ul>
</blockquote>
<h3 id="Stub类的asInterface方法"><a href="#Stub类的asInterface方法" class="headerlink" title="Stub类的asInterface方法"></a>Stub类的asInterface方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> net.shopin.myaidlserver.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//String DESCRIPTOR = "net.shopin.myaidlserver.IBookManager"</span></span><br><span class="line">	<span class="comment">//因为是跨进程，所以这里实际执行的是BinderProxy的queryLocalInterface方法</span></span><br><span class="line">	<span class="comment">//所以因为是跨进程，这里返回的一定是null</span></span><br><span class="line">	android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">	<span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> net.shopin.myaidlserver.IBookManager))) &#123;</span><br><span class="line">		<span class="keyword">return</span> ((net.shopin.myaidlserver.IBookManager) iin);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不同进程的话，返回一个IBookManager的代理类，并传入服务端相应的binder实例</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> net.shopin.myaidlserver.IBookManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BinderProxy的queryLocalInterface方法"><a href="#BinderProxy的queryLocalInterface方法" class="headerlink" title="BinderProxy的queryLocalInterface方法"></a>BinderProxy的queryLocalInterface方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span><span class="params">(String descriptor)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//内部没有实现，默认返回null</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Binder的queryLocalInterface方法"><a href="#Binder的queryLocalInterface方法" class="headerlink" title="Binder的queryLocalInterface方法"></a>Binder的queryLocalInterface方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IInterface <span class="title">queryLocalInterface</span><span class="params">(String descriptor)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mDescriptor.equals(descriptor)) &#123;</span><br><span class="line">		<span class="comment">//直接返回mOwner，mOwner在上边已经说了</span></span><br><span class="line">		<span class="keyword">return</span> mOwner;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Proxy代理类"><a href="#Proxy代理类" class="headerlink" title="Proxy代理类"></a>Proxy代理类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">net</span>.<span class="title">shopin</span>.<span class="title">myaidlserver</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">	Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">		<span class="comment">//服务端返回的binder实例或者是BinderProxy代理类</span></span><br><span class="line">		mRemote = remote;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据mRemote来调用相应的方法</span></span><br><span class="line">	getBookList()&#123;</span><br><span class="line">		mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	addBook()&#123;</span><br><span class="line">		mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>客户端同样会自动生成一个Stub类，但是客户端不会用这个Stub实例，只会用Stub的静态内部类Proxy，通过这个Proxy对应到服务端的Stub类。</p>
</blockquote>
<blockquote>
<p><strong>一个服务对应的有一个binder实例，服务端曝露出这个binder实例（或者是此binder的代理实例）给客户端，客户端根据这个binder实例生成相应的服务代理类，在服务代理类中通过服务端暴漏的那个binder或代理类调用目标方法，此时这个通信过程会交由内核层处理也就是/dev/binder来桥接，然后再返回到应用层，交由真正的服务端对应的方法处理。</strong><br>一次通信完成。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/02/android/AIDL流程分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/02/android/AIDL流程分析/" itemprop="url">AIDL流程分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-02T14:29:26+08:00">
                2018-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/14/spring/SOA 学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/14/spring/SOA 学习笔记/" itemprop="url">SOA 学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-14T13:43:05+08:00">
                2018-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SOA-学习笔记"><a href="#SOA-学习笔记" class="headerlink" title="SOA 学习笔记"></a>SOA 学习笔记</h2><h3 id="SOA项目搭建篇"><a href="#SOA项目搭建篇" class="headerlink" title="SOA项目搭建篇"></a>SOA项目搭建篇</h3><p><strong>主要目标是：完全清楚为什么要这么搭建，如何体现解耦、复用</strong></p>
<ol>
<li>大致的继承关系</li>
</ol>
<p><img src="/2018/04/14/spring/SOA 学习笔记/./1534138305704.png" alt="Alt text"></p>
<ul>
<li><p>SOATopPom</p>
<blockquote>
<p>dependency parent是spring-boot-starter-parent<br>最基础的项目只包含一个pom.xml文件，里边主要是：<br>1、第三方的依赖<br>2、伺服地址配置<br>3、部署构件配置<br>4、对于SP项目来说，spring-boot-starter等aop、web包没有包含在这个pom.xml文件中</p>
</blockquote>
</li>
<li><p>SOAParent</p>
<blockquote>
<p>SOAParent是聚合项目（一个prj包含多个module）<br>主项目也只包含一个pom.xml文件，里边是业务层所需的依赖<br>module：<br>  IService - jar：只写具体的接口，不写实现<br>  bean - jar<br>  dao - jar</p>
</blockquote>
</li>
<li><p>SOAProvider</p>
<blockquote>
<p>dependency parent为SOAParent，主要作用是实现IService，规范的情况下，provider中只有serviceImpl，并把实现了的service注册到zookeeper</p>
</blockquote>
</li>
<li><p>SOAConsumer</p>
<blockquote>
<p>consumer的dependency parent不需要为SOAParent（正常情况下消费者是与后台无关的，除非是一个系统既是consumer，又是provider），它只要引入对应的IService就行。</p>
</blockquote>
</li>
</ul>
<h3 id="Dubbo篇"><a href="#Dubbo篇" class="headerlink" title="Dubbo篇"></a>Dubbo篇</h3><h3 id="zookeeper篇"><a href="#zookeeper篇" class="headerlink" title="zookeeper篇"></a>zookeeper篇</h3><ol>
<li><p>zookeeper默认的三个端口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对client端提供服务，在provider和consumer中设置registry时使用</span></span><br><span class="line"><span class="number">2181</span></span><br><span class="line"><span class="comment">//服务器与集群中的 Leader 服务器交换信息的端口</span></span><br><span class="line"><span class="number">2888</span></span><br><span class="line"><span class="comment">//一旦集群中的 Leader 服务器挂了，需要一个端口重新进行选举，选出一个新的 Leader</span></span><br><span class="line"><span class="number">3888</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.properties中spring-dubbo的配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用名称</span></span><br><span class="line">spring.dubbo.application.name=dubbo_consumer</span><br><span class="line"><span class="comment">//注册中心地址</span></span><br><span class="line"><span class="comment">//两台服务器，三个zookeeper注册中心（算是伪集群）</span></span><br><span class="line">spring.dubbo.registry.address=zookeeper:<span class="comment">//172.16.103.146:2281?backup=172.16.103.19:2281,172.16.103.136:2381</span></span><br><span class="line"><span class="comment">//协议名称</span></span><br><span class="line">spring.dubbo.protocol.name=dubbo</span><br><span class="line"><span class="comment">//协议端口</span></span><br><span class="line">spring.dubbo.protocol.port=<span class="number">20800</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">spring.dubbo.registry.timeout=<span class="number">6000</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Dubbo-Admin搭建"><a href="#Dubbo-Admin搭建" class="headerlink" title="Dubbo-Admin搭建"></a>Dubbo-Admin搭建</h3><ol start="2">
<li>出现的问题<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. It is probably not running</span><br><span class="line">	删除data下面除myid之外的其它文件</span><br><span class="line">	保证dataDir、dataDirLog的路径是正确的</span><br><span class="line"><span class="number">2</span>. 实验证明，当provider写了版本号后，consumer必须也要写版本号，不然引不到</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<blockquote>
<p>后台学习推荐书籍<br>spring in action 第四版<br>springboot 揭秘  配合博客<br>dubbo 官网<br>《大型网站技术架构：核心原理与案例分析》<br>《大型网站系统与Java中间件实践》<br>大型分布式网站架构设计与实践<br>SOA理解<br>redis<br>redis开发与运维</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/android/Binder机制分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/android/Binder机制分析/" itemprop="url">Binder机制分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-02T14:29:37+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="结合AIDL分析Binder机制"><a href="#结合AIDL分析Binder机制" class="headerlink" title="结合AIDL分析Binder机制"></a>结合AIDL分析Binder机制</h2><h3 id="AIDL使用流程"><a href="#AIDL使用流程" class="headerlink" title="AIDL使用流程"></a>AIDL使用流程</h3><blockquote>
<ol>
<li>aidl文件—&gt;直接用as生成aidl文件就行，他会默认生成一个aidl文件夹，创建Book.java在java下的包下，而Book.aidl在aidl下的包下，注意这两个包名必须一致—&gt;这点as会帮我们做。</li>
<li>aidl demo server-d:\myprjs\aidl\client\MyApplication</li>
<li>aidl demo client-d:\myprjs\aidl\server\MyAidlServer</li>
</ol>
</blockquote>
<h4 id="服务端Service"><a href="#服务端Service" class="headerlink" title="服务端Service"></a>服务端Service</h4><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManageService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"CLIENT_ERROR_LOG"</span>;</span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面分析mBinder</span></span><br><span class="line">    <span class="keyword">private</span> IBinder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">		<span class="comment">//service在create时先添加一本书</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Book(<span class="number">1001</span>, <span class="string">"谁许传"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在客户端与服务端建立连接时传给客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//把服务端的Binder对象传给client端</span></span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="mBinder对象"><a href="#mBinder对象" class="headerlink" title="mBinder对象"></a>mBinder对象</h5><blockquote>
<p>我们在.aidl中定义的那些操作，真正的执行体在这里<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建这个Binder就是为了暴露给客户端</span></span><br><span class="line"><span class="comment"> * 客户端拿到server端的binder执行add，get方法时，经过一系列转换，最后走的就是这里。</span></span><br><span class="line"><span class="comment"> * IBookManager.aidl的这4个方法都执行在binder线程中</span></span><br><span class="line"><span class="comment"> * 注意mBinder是如何生成的：mBinder指向了一个匿名内部类（注意这个匿名内部类，下边的分析会提到）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> IBinder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">		<span class="comment">//添加是在client的主线程中add的，但是这里走到了binder线程</span></span><br><span class="line">		list.add(book);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="客户端绑定服务端Service"><a href="#客户端绑定服务端Service" class="headerlink" title="客户端绑定服务端Service"></a>客户端绑定服务端Service</h4><h5 id="获得要绑定的connection"><a href="#获得要绑定的connection" class="headerlink" title="获得要绑定的connection"></a>获得要绑定的connection</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client端定义的connection</span></span><br><span class="line"><span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">//根据server端的binder对象调用AIDL中的Stub类的asInterface方法</span></span><br><span class="line">	    <span class="comment">//最终返回的是一个Proxy对象-实现了IBookManager接口（因为不是在同一进程，所以会用代理实现跨进程通信）</span></span><br><span class="line">	    <span class="comment">//相当于是本地的Proxy代理了远程的Binder，生成了一个Manager对象(即IInterface的实现类，里边有Binder)，但最终执行时肯定还是要通过被代理对象的。</span></span><br><span class="line">	    <span class="comment">//【注意：】上述的service对象实际是BinderProxy类型的对象</span></span><br><span class="line">        bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"onServiceDisconnected: "</span> + name.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">"net.shopin.aidlservice"</span>);</span><br><span class="line">intent.setPackage(<span class="string">"net.shopin.myaidlserver"</span>);</span><br><span class="line"><span class="comment">//与服务端建立连接</span></span><br><span class="line"><span class="comment">//这边有个小问题：在api&gt;21时，上述的intent不仅要加action，还要加package</span></span><br><span class="line">bindService(intent, connection, Context.BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>
<h3 id="由AIDL自动生成的类"><a href="#由AIDL自动生成的类" class="headerlink" title="由AIDL自动生成的类"></a>由AIDL自动生成的类</h3><h4 id="Server端的IBookManager接口"><a href="#Server端的IBookManager接口" class="headerlink" title="Server端的IBookManager接口"></a>Server端的IBookManager接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">net</span>.<span class="title">shopin</span>.<span class="title">myaidlserver</span>.<span class="title">IBookManager</span></span>&#123;</span><br><span class="line">		<span class="comment">//下边分析Stub类</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 下面的方法就是我们在.aidl文件中定义的。</span></span><br><span class="line"><span class="comment">	* 可以肯定：必须会有一个类来实现这些方法，不然我们定义的操作没有执行体！</span></span><br><span class="line"><span class="comment">	* 那么是谁呢？就看谁实现了IBookManager接口===&gt;Stub类</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">public</span> java.util.<span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IBookManager接口中的Stub类"><a href="#IBookManager接口中的Stub类" class="headerlink" title="IBookManager接口中的Stub类"></a>IBookManager接口中的Stub类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Local-side IPC implementation stub class.</span></span><br><span class="line"><span class="comment"> * 注意：Stub继承Binder，实现IBookManager，但它是一个抽象类，并且也是自动生成的-说明我们定义的那些操作的执行体肯定不在这里边-肯定在Stub的子类中-就是我们在Service中为了生成mBinder而定义的那个匿名内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">net</span>.<span class="title">shopin</span>.<span class="title">myaidlserver</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"net.shopin.myaidlserver.IBookManager"</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Server端的Service构造Binder对象时会走到这里生成一个Stub()实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		注意：开始把当前的this（stub对象）和DESCRIPTOR建立关联</span></span><br><span class="line"><span class="comment">		所以后期：执行binder.queryLocalInterface(DESCRIPTOR)时，</span></span><br><span class="line"><span class="comment">		就是根据这里attach的对应关系来查找的</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> net.shopin.myaidlserver.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//具体代码下边分析</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">		<span class="comment">//下边分析</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">net</span>.<span class="title">shopin</span>.<span class="title">myaidlserver</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">		<span class="comment">//下边分析</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Stub类中的asInterface方法"><a href="#Stub类中的asInterface方法" class="headerlink" title="Stub类中的asInterface方法"></a>Stub类中的asInterface方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cast an IBinder object into an net.shopin.myaidlserver.IBookManager interface, generating a proxy if needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> net.shopin.myaidlserver.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//DESCRIPTOR就是包名+类名（string类型）</span></span><br><span class="line">       IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">       <span class="comment">//那么问题是：什么时候if条件不成立？</span></span><br><span class="line">       <span class="comment">//注意queryLocalInterface方法：在本地（指的就是当前进程）查找是否有DESCRIPTOR对应的IInterface</span></span><br><span class="line">       <span class="comment">//在Server端时，obj.queryLocalInterface是可以找到对应的DESCRIPTOR，因为此时Binder对象所处的进程和调用者所处的是同一个进程（这里的调用者指的就是bookManager.addBook操作所处的进程），但是当把server端的service设置为remote进程时，调用者和binder对象所处的就不是同一个进程了(此时，Binder就成为一个远程对象了)！</span></span><br><span class="line">       <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> net.shopin.myaidlserver.IBookManager))) &#123;</span><br><span class="line">           <span class="keyword">return</span> ((net.shopin.myaidlserver.IBookManager) iin);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//既然不在同一个进程，那如何获取到远程的(binder)对象实例来操作呢？</span></span><br><span class="line">       <span class="comment">//通过代理（和java的代理实现方式不一样）返回对应的IBookManager实现类（也就是Proxy类），也就是说以后操作IBookManager类的各个方法都是先操作Proxy，最后才到被代理对象了</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> net.shopin.myaidlserver.IBookManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Stub的onTransact方法"><a href="#Stub的onTransact方法" class="headerlink" title="Stub的onTransact方法"></a>Stub的onTransact方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这是Stub类中的onTransact方法，不同进程通信时才会走这里！</span></span><br><span class="line"><span class="comment">* 同一进程通信时（比如当前应用注册当前的Service(没有设置remote)，使用AIDL通信，直接就会走到Service中的匿名内部类中，不会经过这一系列的操作）</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">	<span class="comment">//方法中的参数就是client调用transact方法时传过来的</span></span><br><span class="line">	<span class="keyword">switch</span> (code) &#123;</span><br><span class="line">		<span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">			reply.writeString(DESCRIPTOR);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> TRANSACTION_getBookList: &#123;</span><br><span class="line">			data.enforceInterface(DESCRIPTOR);</span><br><span class="line">			List&lt;Book&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">			reply.writeNoException();</span><br><span class="line">			reply.writeTypedList(_result);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> TRANSACTION_addBook: &#123;</span><br><span class="line">			data.enforceInterface(DESCRIPTOR);</span><br><span class="line">			net.shopin.myaidlserver.Book _arg0;</span><br><span class="line">			<span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</span><br><span class="line">				_arg0 = net.shopin.myaidlserver.Book.CREATOR.createFromParcel(data);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				_arg0 = <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//注意下边的this.getBookList()，调的就是子类（那个匿名内部类）的getBookList方法</span></span><br><span class="line">			<span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">			reply.writeNoException();</span><br><span class="line">			<span class="comment">//注意这里直接返回了，并没有再调到Binder的onTransact</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代理类Proxy"><a href="#代理类Proxy" class="headerlink" title="代理类Proxy"></a>代理类Proxy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">net</span>.<span class="title">shopin</span>.<span class="title">myaidlserver</span>.<span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">    <span class="comment">//这个remote是在client中构建ServiceConnection时，onServiceConnected方法传来的，实际上还是Server的Service传来的Binder对象---&gt;也就是IBookManager.Stub()</span></span><br><span class="line">    Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">	    <span class="comment">//当执行this.asBinder()时，会把这个binder对象返回</span></span><br><span class="line">        mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(net.shopin.myaidlserver.Book book)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">        android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">        android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">	        <span class="comment">//写入类名，类似于标记吧，只要类名一致都可以反序列化</span></span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _data.writeInt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此处执行IBookManager.Stub()的transact方法</span></span><br><span class="line">            <span class="comment">//可以发现：此处真正执行的addBook方法，最终还是通过一个转换</span></span><br><span class="line">            <span class="comment">//mRemote.transact(Stub.TRANSACTION_addBook来实现的。</span></span><br><span class="line">            <span class="comment">//那么mRemote是谁呢？就是onServiceConnected传回来的Server端的IBinder，但是transact是父类Binder的方法，下边分析</span></span><br><span class="line">            mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">            _reply.readException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Binder中用到的方法"><a href="#Binder中用到的方法" class="headerlink" title="Binder中用到的方法"></a>Binder中用到的方法</h3><h4 id="transact方法"><a href="#transact方法" class="headerlink" title="transact方法"></a>transact方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 上述Proxy中的mRemote.transact方法最终执行Binder中的transact方法（这点通</span></span><br><span class="line"><span class="comment">* 过debug还未发现！），在该方法中依旧会调用onTransact方法-因为在Stub（Binder</span></span><br><span class="line"><span class="comment">* 的子类）中重写了(自动生成)onTransact方法，所以会先执行Stub类的onTransact</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">        data.setDataPosition(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行onTransact方法（先执行我们在service中重写的onTransact方法[根据需要选择是否重写]，再执行Stub中自动生成的onTransact方法===&gt;完成跨进程通信）</span></span><br><span class="line">    <span class="keyword">boolean</span> r = onTransact(code, data, reply, flags);</span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reply.setDataPosition(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上面分析完成后，开始执行add方法"><a href="#上面分析完成后，开始执行add方法" class="headerlink" title="上面分析完成后，开始执行add方法"></a>上面分析完成后，开始执行add方法</h3><p>bookManager.addBook(book);<br>客户端用manager add了book，那么真正的执行体在哪呢？<br><img src="/2018/04/02/android/Binder机制分析/./1546689948194.png" alt="Alt text"></p>
<ol>
<li>回想上边：manager如何生成的？根据Proxy和远程的IBinder生成的</li>
<li><p>当执行add方法时，执行的是Proxy中的add方法<br><img src="/2018/04/02/android/Binder机制分析/./1546690064092.png" alt="Alt text"></p>
</li>
<li><p>观察上边client中Proxy的add方法…最终执行的还是IBinder<br>的transact方法—&gt;也就是Binder（注意：这个Binder指的是remote）的transact方法—&gt;最终会映射到Binder进程（dev/binder）</p>
<blockquote>
<p>第三步有些疑惑：通过debug并没有看到client执行mRemote时，server端有执行Binder的transact方法（难道是远程调用的原因？不清楚），直接执行的是onTransact！这点很奇怪，难道不是：<font color="#AA8800">client执行transact—&gt;server端的Binder.java的transact—&gt;server端实现IBinder.java的子类的onTransact？？？</font><br><font color="#FF0000">事实不太清楚，但大致的执行流程肯定是：<br>remote.transact执行后会通过binder机制（和dev/binder有关了）来远程映射到server端的onTransact方法，远程的onTransact通过其参数（data、code）找到对应的方法，进行相应的操作。<br></font><br><img src="/2018/04/02/android/Binder机制分析/./1546697701352.png" alt="Alt text"></p>
</blockquote>
</li>
</ol>
<p><img src="/2018/04/02/android/Binder机制分析/./1546697857391.png" alt="Alt text"></p>
<ol start="5">
<li>OK，一次读/写完成</li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>为什么可以实现跨进程通信？原理是什么？</p>
<p><img src="/2018/04/02/android/Binder机制分析/./1546618047950.png" alt="Alt text"><br><img src="/2018/04/02/android/Binder机制分析/./1546618062864.png" alt="Alt text"><br>如上图所示：server的service打印出的线程名是 9692_2，但可以看出进程是9692（是myaidlserver应用的），那么到底是Binder进程是哪个进程号？难道是因为没有设置service的remote？因为设置之后就表示是单独进程了！<br><img src="/2018/04/02/android/Binder机制分析/./1546620099505.png" alt="Alt text"><br><strong>如上图所示，确实是这样，设置其为单独的服务，并且设置名字后，发现果然成为了一个单独的服务！</strong></p>
<p>那么到底什么是Binder进程？client与server通信时，说的是靠Binder进程从中调解，但事实是 靠的是 开启的那个service所在的那个进程？</p>
<blockquote>
<font color="#FF0000"><strong>注意</strong>：不要说Binder进程，Binder就是Binder，它是进程间通信时创建的一个对象，是一个桥梁，它是系统层面的一个进程！Binder内部维护了一个Binder线程池</font>
</blockquote>
<h3 id="AIDL编写时遇到的问题"><a href="#AIDL编写时遇到的问题" class="headerlink" title="AIDL编写时遇到的问题"></a>AIDL编写时遇到的问题</h3><ol>
<li>关于找不到Book.java文件的问题<blockquote>
<p>把Book.aidl放在了aidl包下，Book.java也放在了aidl包下就找不到了，原因是as只会去java下边找java文件，解决办法：</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>方案1：build文件修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        java.srcDirs = [<span class="string">'src/main/java'</span>, <span class="string">'src/main/aidl'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方案2：把aidl放在as创建的aidl包下，把java放在java包下</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">第一种方案</th>
<th style="text-align:center">第二种方案</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="/2018/04/02/android/Binder机制分析/./1536638215799.png" alt="Alt text"></td>
<td style="text-align:center"><img src="/2018/04/02/android/Binder机制分析/./1536641847499.png" alt="Alt text"></td>
</tr>
</tbody>
</table>
<ol start="2">
<li><p>对于往客户端放置aidl文件时有些问题</p>
<blockquote>
<p>在as中，aidl文件只能放在系统生成的aidl文件夹下(应该是这样的)，而系统生成的aidl文件夹的包名是和java文件夹下的包名是一样的，所以直接把服务端的aidl文件放在aidl文件夹下肯定不行—因为包名不一致，如果尝试把aidl下的包名改成和服务端一致的，也不行，会导致java下面的包也会随之改变。其实解决办法就是在net.shopin下新建一个myaidlserver包，如下图，新建一个包A，这样就保证了server和client的aid包名一直。让然此时也可以把myaidlclient包删除了。至于B，如果是按照上述第二种方案解决的，则也要在java下新建同样的包来存放java文件了。<br><img src="/2018/04/02/android/Binder机制分析/./1536648684435.png" alt="Alt text"></p>
</blockquote>
</li>
<li><p>连接service时报错</p>
<blockquote>
<p>Service Intent must be explicit: Intent { act=net.shopin.aidlservice }，可以看下ContextImpl源码，看下service和contextimpl什么关系</p>
</blockquote>
</li>
</ol>
<h3 id="AIDL权限问题"><a href="#AIDL权限问题" class="headerlink" title="AIDL权限问题"></a>AIDL权限问题</h3><p>控制client调用权限</p>
<ol>
<li>在onBind方法中控制</li>
<li>在onTransact方法中控制</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/25/android/一大句话阐述事件分发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/android/一大句话阐述事件分发/" itemprop="url">一大句话阐述事件分发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-25T11:37:07+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一大句话阐述事件分发"><a href="#一大句话阐述事件分发" class="headerlink" title="一大句话阐述事件分发"></a>一大句话阐述事件分发</h2><h3 id="事件传递到Activity"><a href="#事件传递到Activity" class="headerlink" title="事件传递到Activity"></a>事件传递到Activity</h3><blockquote>
<ol>
<li>AMS在启动Activity时，会在ActivityThread的performLaunchActivity方法中去执行<code>activity.attach</code>，在attach中会构造一个window实例（PhoneWindow类型）并把当前Activity实例传过去，便于后期回调，在构造Window过程中会产生一个DecorView，这就是应用的根布局（整个应用中应该只有一个DecorView，那就是main Activity的，其它的Activity都是用的这一个）。在根布局显示时会再构造一个ViewRootImpl实例，并把ViewRootImpl、Window、DecorView相互关联起来，这时就可以接收外部输入事件了。</li>
<li>当有Input事件时，事件会分发给WindowInputEventReceiver（ViewRootImpl的内部类），receiver接收到事件后最终会调用上述DecorView的dispatchTouchEvent方法，并在dispatch中通过上述传过来的Activity实例回调到Activity的dispatch中。</li>
</ol>
</blockquote>
<h3 id="View-ViewGroup的事件传递"><a href="#View-ViewGroup的事件传递" class="headerlink" title="View / ViewGroup的事件传递"></a>View / ViewGroup的事件传递</h3><blockquote>
<ol>
<li>在Activity的dispatch中会直接调用Window的superDispatch，然后调DecorView的superDispatch，最终走到ViewGroup的dispatch中（这个过程都是直接调用，没有任何逻辑，我的理解这里就是为了能把Activity接收的事件丢出来，丢给Activity自己的contentView），在VG中先判断onIntrcept是否拦截：</li>
</ol>
<ul>
<li>拦截的话会直接执行View的dispatch方法，并且在dispatch中判断是否有touch事件，以及touch事件的返回值—如果为true则直接view的dispatch直接返回true，否则执行onTouchEvent，并执行onClick，dispatch最终的返回值由onTouchEvent决定。</li>
<li>不拦截的话，会先判断当前事件是不是down，不是的话说明已经有消费事件的目标view了，也就是mFirstTouchTarget，直接执行target的dispatch方法。是down事件的话会遍历其子view，找到消费事件的目标view，赋值为mFirstTouchTarget，最终执行mFirstTouchTarget的dispatch方法。</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/24/android/事件如何分发到Activity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="changePosition">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="changePosition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/24/android/事件如何分发到Activity/" itemprop="url">事件如何分发到Activity</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T14:59:27+08:00">
                2018-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Activity的attach方法"><a href="#Activity的attach方法" class="headerlink" title="Activity的attach方法"></a>Activity的attach方法</h2><blockquote>
<p>在ActivityThread中的H发送RESUME_ACTIVITY消息时，会在performResumeActivity中执行activity.attch</p>
</blockquote>
<h3 id="attach做了什么"><a href="#attach做了什么" class="headerlink" title="attach做了什么"></a>attach做了什么</h3><h5 id="1-在attach时创建一个window，并让当前Activity与Window建立关联"><a href="#1-在attach时创建一个window，并让当前Activity与Window建立关联" class="headerlink" title="1. 在attach时创建一个window，并让当前Activity与Window建立关联"></a>1. 在attach时创建一个window，并让当前Activity与Window建立关联</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的this是当前activity</span></span><br><span class="line">mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line"><span class="comment">//this是当前activity（这里很重要，最后会通过这个回调），设置CallBack，实现dispatchTouchEvent方法</span></span><br><span class="line">mWindow.setCallback(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<h5 id="2-PhoneWindow的构造方法"><a href="#2-PhoneWindow的构造方法" class="headerlink" title="2. PhoneWindow的构造方法"></a>2. PhoneWindow的构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PhoneWindow</span><span class="params">(Context context, Window preservedWindow, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//Only main activity windows use decor context, all the other </span></span><br><span class="line">	<span class="comment">//windows depend on whatever context that was given to them.</span></span><br><span class="line">	<span class="keyword">if</span> (preservedWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//得到main传过来的DecorView</span></span><br><span class="line">		mDecor = (DecorView) preservedWindow.getDecorView();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>很重要的一点：一个应用里边的DecorView只有一个。</p>
</blockquote>
<h5 id="3-执行完performResumeActivity后会继续在handleResume方法中调用activity的makeVisible方法"><a href="#3-执行完performResumeActivity后会继续在handleResume方法中调用activity的makeVisible方法" class="headerlink" title="3. 执行完performResumeActivity后会继续在handleResume方法中调用activity的makeVisible方法"></a>3. 执行完performResumeActivity后会继续在handleResume方法中调用activity的makeVisible方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">		<span class="comment">//追踪getWM最终看到得到的是一个</span></span><br><span class="line">		ViewManager wm = getWindowManager();</span><br><span class="line">		<span class="comment">//往当前窗口添加DecorView</span></span><br><span class="line">		wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">		mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//显示decorView，也就是contentView也显示了</span></span><br><span class="line">	mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以这个时候contentView才是显示状态，也就是在onResume过程中才显示，才可交互。</p>
</blockquote>
<h5 id="4-看下addView方法"><a href="#4-看下addView方法" class="headerlink" title="4. 看下addView方法"></a>4. 看下addView方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WindowManagerImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">	mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="构造一个ViewRootImpl，并把root、decor、window建立关联"><a href="#构造一个ViewRootImpl，并把root、decor、window建立关联" class="headerlink" title="构造一个ViewRootImpl，并把root、decor、window建立关联"></a>构造一个ViewRootImpl，并把root、decor、window建立关联</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WindowManagerGlobal.java</span></span><br><span class="line"><span class="comment">//参数view就是传过来的DecorView</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">	ViewRootImpl root;</span><br><span class="line">	<span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">		<span class="comment">//构造一个ViewRootImpl实例</span></span><br><span class="line">		root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">		view.setLayoutParams(wparams);</span><br><span class="line">		mViews.add(view);</span><br><span class="line">		mRoots.add(root);</span><br><span class="line">		mParams.add(wparams);</span><br><span class="line">		<span class="comment">//ViewRootImpl实例与DecorView实例建立关联，下面会用到这个view</span></span><br><span class="line">		root.setView(view, wparams, panelParentView);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-在ViewRootImpl的add方法中会构造一个WindowInputEventReceiver实例，用于接收input事件"><a href="#5-在ViewRootImpl的add方法中会构造一个WindowInputEventReceiver实例，用于接收input事件" class="headerlink" title="5. 在ViewRootImpl的add方法中会构造一个WindowInputEventReceiver实例，用于接收input事件"></a>5. 在ViewRootImpl的add方法中会构造一个WindowInputEventReceiver实例，用于接收input事件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel, Looper.myLooper());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WindowInputEventReceiver是ViewRootImpl的内部类，从类名可以看出它就是接收输入事件的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowInputEventReceiver</span> <span class="keyword">extends</span> <span class="title">InputEventReceiver</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当有事件输入时，父类会回调给onInputEvent方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputEvent</span><span class="params">(InputEvent event)</span></span>&#123;</span><br><span class="line">		enqueueInputEvent(event, <span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBatchedInputEventPending</span><span class="params">()</span>...</span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span>...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>其父类InputEventReceiver有一个dispatchInputEvent方法用于分发接收到的事件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InputEventReceiver.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchInputEvent</span><span class="params">(<span class="keyword">int</span> seq, InputEvent event)</span> </span>&#123;</span><br><span class="line">	mSeqMap.put(event.getSequenceNumber(), seq);</span><br><span class="line">	<span class="comment">//会继续调用子类也就是上边WindowInputEventReceiver的onInputEvent方法</span></span><br><span class="line">	onInputEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueInputEvent</span><span class="params">(InputEvent event, InputEventReceiver receiver, <span class="keyword">int</span> flags, <span class="keyword">boolean</span> processImmediately)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//从这里可以看出：Input事件也是一个一个的消息，是一个链表结构，一个一个发</span></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (processImmediately) &#123;</span><br><span class="line">		<span class="comment">//立即发消息</span></span><br><span class="line">		doProcessInputEvents();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//应该是延迟发消息（内部会调用handler在“合适的时间发送”）</span></span><br><span class="line">		scheduleProcessInputEvents();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessInputEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Deliver all pending input events in the queue.</span></span><br><span class="line">	<span class="comment">//循环发出队列中的全部消息</span></span><br><span class="line">	<span class="keyword">while</span> (mPendingInputEventHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">		QueuedInputEvent q = mPendingInputEventHead;</span><br><span class="line">		mPendingInputEventHead = q.mNext;</span><br><span class="line">		<span class="comment">//通过这个方法分发事件</span></span><br><span class="line">		deliverInputEvent(q);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交付（有点分发的意思）事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverInputEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">	InputStage stage;</span><br><span class="line">	<span class="keyword">if</span> (q.shouldSendToSynthesizer()) &#123;</span><br><span class="line">		stage = mSyntheticInputStage;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;</span><br><span class="line">	&#125;</span><br><span class="line">	stage.deliver(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//注意看这里有个onProcess方法，它是InputStage中的方法，但是InputStage是个抽象类，所以这里可能是调其子类的onProcess方法</span></span><br><span class="line">	apply(q, onProcess(q));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>InputStage的实现类：</p>
<ul>
<li>ViewPreImeInputStage</li>
<li>EarlyPostImeInputStage</li>
<li>ViewPostImeInputStage</li>
<li>SyntheticInputStage<br><strong>我们的触摸事件走的应该是ViewPostImeInputStage这个</strong></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">onProcess</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (q.mEvent <span class="keyword">instanceof</span> KeyEvent) &#123;</span><br><span class="line">		<span class="comment">//输入事件（如键盘）</span></span><br><span class="line">		<span class="keyword">return</span> processKeyEvent(q);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//手指触摸事件</span></span><br><span class="line">		<span class="keyword">return</span> processPointerEvent(q);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-最终会调用decorView的dispatchPointerEvent分发"><a href="#6-最终会调用decorView的dispatchPointerEvent分发" class="headerlink" title="6. 最终会调用decorView的dispatchPointerEvent分发"></a>6. 最终会调用decorView的dispatchPointerEvent分发</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processPointerEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;</span><br><span class="line">	<span class="comment">//这个mView就是上边ViewRootImpl.setView设置的</span></span><br><span class="line">	<span class="keyword">boolean</span> handled = mView.dispatchPointerEvent(event);</span><br><span class="line">	<span class="keyword">return</span> handled ? FINISH_HANDLED : FORWARD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-dispatchPointerEvent又会调用自己的dispatchTouchEvent，也就是decorview的dispatchTouchEvent"><a href="#7-dispatchPointerEvent又会调用自己的dispatchTouchEvent，也就是decorview的dispatchTouchEvent" class="headerlink" title="7. dispatchPointerEvent又会调用自己的dispatchTouchEvent，也就是decorview的dispatchTouchEvent"></a>7. dispatchPointerEvent又会调用自己的dispatchTouchEvent，也就是decorview的dispatchTouchEvent</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">dispatchPointerEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (event.isTouchEvent()) &#123;</span><br><span class="line">		<span class="comment">//执行DecorView的dispatchTouchEvent方法</span></span><br><span class="line">		<span class="keyword">return</span> dispatchTouchEvent(event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="8-终于，在decorView的dispatch中拿到上边构造window时传的Activity实例回调其dispatch"><a href="#8-终于，在decorView的dispatch中拿到上边构造window时传的Activity实例回调其dispatch" class="headerlink" title="8. 终于，在decorView的dispatch中拿到上边构造window时传的Activity实例回调其dispatch"></a>8. 终于，在decorView的dispatch中拿到上边构造window时传的Activity实例回调其dispatch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这个cb就是Activity实例</span></span><br><span class="line">	<span class="keyword">final</span> Window.Callback cb = mWindow.getCallback();</span><br><span class="line">	<span class="comment">//调用activity的dispatchTouchEvent方法</span></span><br><span class="line">	<span class="keyword">return</span> cb != <span class="keyword">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span>? cb.dispatchTouchEvent(ev) : <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">changePosition</p>
              <p class="site-description motion-element" itemprop="description">知识体系树</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">changePosition</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
